---
title: नव्या नेटवर्क्स संयोजन करणे
---

ग्राफ नोड सध्या खालील साखळी प्रकारातील डेटा अनुक्रमित करू शकतो:

-   Ethereum, via EVM JSON-RPC and [Ethereum Firehose](https://github.com/streamingfast/firehose-ethereum)
-   NEAR, via a [NEAR Firehose](https://github.com/streamingfast/near-firehose-indexer)
-   Cosmos, via a [Cosmos Firehose](https://github.com/graphprotocol/firehose-cosmos)
-   Arweave, via an [Arweave Firehose](https://github.com/graphprotocol/firehose-arweave)

आपल्याला या सगळ्या चेन्समध्ये कोणत्याही आवडल्यास, संयोजन Graph Node सेटिंग आणि परीक्षणाची प्रक्रिया आहे.

आपल्याला विविध चेन प्रकारात आवड आहे तर, तुम्हाला नवीन ग्राफ नोडसह संयोजन करण्याची आवश्यकता आहे. आमच्या शिफारसनुसार, तुमच्या चेनसाठी एक Firehose विकसित करायला आवश्यक आहे, आणि नंतर त्या Firehose ची ग्राफ नोडसह संयोजन करण्याची प्रक्रिया अपनावी.

** 1. EVM JSON-RPC**

जर ब्लॉकचेन EVM समतुल्य असेल आणि क्लायंट/नोडने मानक EVM JSON-RPC API उघड केले, तर ग्राफ नोड नवीन साखळी अनुक्रमित करण्यास सक्षम असावा. अधिक माहितीसाठी, [इव्हीएम जेएसओएन-आरपीसीची चाचणी करणे](नवीन-चेन-एकीकरण#testing-an-evm-json-rpc) पहा.

**2. Firehose**

नॉन-ईव्हीएम-आधारित साखळींसाठी, ग्राफ नोडला gRPC आणि ज्ञात प्रकारच्या व्याख्यांद्वारे ब्लॉकचेन डेटा अंतर्भूत करणे आवश्यक आहे. हे [Firehose](firehose/README/) द्वारे केले जाऊ शकते, [StreamingFast](https://www.streamingfast.io/) ने विकसित केलेले नवीन तंत्रज्ञान जे फाइल-आधारित आणि वापरून उच्च-स्केलेबल इंडेक्सिंग ब्लॉकचेन सोल्यूशन प्रदान करते. प्रवाह-प्रथम दृष्टीकोन.

## EVM JSON-RPC आणि Firehose मधील फरक

यादोनाया सबग्राफ्ससाठी दोन वर्ग उपयुक्त आहेत, परंतु [Substreams](substreams/) साठी विकसित करणार्या विकासकांसाठी Firehoseची सदैव आवश्यकता आहे, जसे की [Substreams-powered subgraphs](cookbook/substreams-powered-subgraphs/) विकसित करणे. वाढलेल्या सूचीकरण गतींच्या सुधारणेची स्वीकृती केल्यामुळे Firehoseच्या तुलनेत JSON-RPCशी इंडेक्सिंग स्पीडमध्ये सुधारले जाते.

नव्या EVM चेन एक्सप्रेसच्या संयोजकांनी योग्यता आणि त्याच्या विशाल समांतरीकृत सूचीकरण क्षमतेच्या लाभांमुळे Firehose-आधारित मार्गाचा विचार करू शकता. दोन्ही समर्थन करणे विकासकांना नव्या चेनसाठी सबस्ट्रीम्स किंवा सबग्राफ्स निर्माण करायला मिळते.

> **टीप**: EVM चेनसाठी Firehose-आधारित संयोजनाची कामगिरी सुबग्राफ्स योग्य रिफरेंस पुरविण्यासाठी इंडेक्सर्सना चेनची आर्काईव RPC नोड चालवण्याची आवश्यकता आहे. हे Firehoseच्या अयोग्यतेचा कारण आहे की, विद्वेषवादीपणे 'eth_call' RPC मेथडने सामान्यपणे प्राप्त केलेले स्मार्ट कॉन्ट्रॅक्ट स्टेट प्रदान करण्याची क्षमता नसलेल्या आहे. (https://thegraph.com/blog/improve-subgraph-performance-reduce-eth-calls/))

* * *

## EVM JSON-RPC ची चाचणी करत आहे

ग्राफ नोडला एक EVM चेनमधून डेटा इन्जेस्ट करण्यासाठी, आरपीसी नोडने खालील EVM JSON RPC मेथड्स व्यक्त करणे आवश्यक आहे:

-   `eth_getLogs`
-   `eth_call` \_(for historical blocks, with EIP-1898 - requires archive node):
-   `eth_getBlockByNumber`
-   `eth_getBlockByHash`
-   `net_version`
-   `eth_getTransactionReceipt`, in a JSON-RPC batch request
-   _`trace_filter`_ _(optionally required for Graph Node to support call handlers)_

### ग्राफ नोड संवादसूचना

**तुमच्या स्थानिक पर्यावरणाची तयारी करून सुरू करा**

1.  [Clone Graph Node](https://github.com/graphprotocol/graph-node)
2.  Modify [this line](https://github.com/graphprotocol/graph-node/blob/master/docker/docker-compose.yml#L22) to include the new network name and the EVM JSON RPC compliant URL
    > Do not change the env var name itself. It must remain `ethereum` even if the network name is different.
3.  Run an IPFS node or use the one used by The Graph: https://api.thegraph.com/ipfs/

\*Test the integration by locally deploying a subgraph\*\*

1.  Install [graph-cli](https://github.com/graphprotocol/graph-cli)
2.  Create a simple example subgraph. Some options are below:
    1.  The pre-packed [Gravitar](https://github.com/graphprotocol/example-subgraph/tree/f89bdd4628efa4badae7367d4919b3f648083323) smart contract and subgraph is a good starting point
    2.  Bootstrap a local subgraph from any existing smart contract or solidity dev environment [using Hardhat with a Graph plugin](https://github.com/graphprotocol/hardhat-graph)
3.  Adapt the resulting `subgraph.yaml` by changing [`dataSources.network`](http://dataSources.network) to the same name previously passed on to Graph Node.
4.  Create your subgraph in Graph Node: `graph create $SUBGRAPH_NAME --node $GRAPH_NODE_ENDPOINT`
5.  Publish your subgraph to Graph Node: `graph deploy $SUBGRAPH_NAME --ipfs $IPFS_ENDPOINT --node $GRAPH_NODE_ENDPOINT`

Graph Node should be syncing the deployed subgraph if there are no errors. Give it time to sync, then send some GraphQL queries to the API endpoint printed in the logs.

* * *

## Integrating a new Firehose-enabled chain

Integrating a new chain is also possible using the Firehose approach. This is currently the best option for non-EVM chains and a requirement for substreams support. Additional documentation focuses on how Firehose works, adding Firehose support for a new chain and integrating it with Graph Node. Recommended docs for integrators:

1.  [General docs on Firehose](firehose/)
2.  [Adding Firehose support for a new chain](firehose/integrate-new-chains/new-blockchains/)
3.  [Integrating Graph Node with a new chain via Firehose](https://github.com/graphprotocol/graph-node/blob/master/docs/implementation/add-chain.md)
