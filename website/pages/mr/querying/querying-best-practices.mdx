---
title: Querying Best Practices
---

The Graph provides a decentralized way to query data from blockchains.

ग्राफ नेटवर्कचा डेटा GraphQL API द्वारे उघड केला जातो, ज्यामुळे GraphQL भाषेसह डेटाची क्वेरी करणे सोपे होते.

हे पृष्‍ठ तुम्हाला GraphQL भाषेचे अत्यावश्यक नियम आणि GraphQL क्वेरी सर्वोत्तम पद्धतींबद्दल मार्गदर्शन करेल.

---

## Querying a GraphQL API

### The anatomy of a GraphQL query

REST API च्या विपरीत, GraphQL API एका स्कीमावर तयार केले जाते जे कोणत्या क्वेरी पूर्ण केल्या जाऊ शकतात हे परिभाषित करते.

For example, a query to get a token using the `token` query will look as follows:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

which will return the following predictable JSON response (_when passing the proper `$id` variable value_):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

GraphQL queries use the GraphQL language, which is defined upon [a specification](https://spec.graphql.org/).

The above `GetToken` query is composed of multiple language parts (replaced below with `[...]` placeholders):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

सिंटॅक्टिक करा आणि करू नका याची यादी लांब असताना, ग्राफक्यूएल क्वेरी लिहिताना लक्षात ठेवण्याचे आवश्यक नियम येथे आहेत:

- Each `queryName` must only be used once per operation.
- Each `field` must be used only once in a selection (we cannot query `id` twice under `token`)
- काही `फील्ड` किंवा क्वेरी (जसे की `टोकन्स`) जटिल प्रकार देतात ज्यांना उप-फील्डची निवड आवश्यक असते. अपेक्षित असताना निवड प्रदान न केल्याने (किंवा अपेक्षित नसताना एक प्रदान करणे - उदाहरणार्थ, `id` वर) त्रुटी वाढवेल. फील्ड प्रकार जाणून घेण्यासाठी, कृपया [द ग्राफ एक्सप्लोरर](/network/explorer) पहा.
- Any variable assigned to an argument must match its type.
- In a given list of variables, each of them must be unique.
- All defined variables must be used.

Failing to follow the above rules will end with an error from the Graph API.

For a complete list of rules with code examples, please look at our GraphQL Validations guide.

### Sending a query to a GraphQL API

ग्राफक्यूएल हे एक भाषा आणि HTTP वर परिवहन करण्याच्या साधना सेट आहे.

हे म्हणजे आपण स्टॅंडर्ड `fetch` (प्राकृतिकपणे किंवा `@whatwg-node/fetch` किंवा `isomorphic-fetch`) वापरून ग्राफक्यूएल एपीआयला क्वेरी करू शकता.

परंतु, ["अनुप्रयोगातून क्वेरी करणे"](/querying/querying-from-an-application) मध्ये दिलेल्या निर्देशानुसार, आम्ही आपल्याला आपल्या `graph-client` वापरण्याची सिफार्से देतो ज्यामुळे अनूठी वैशिष्ट्ये समर्थित केलीत जसे कि:

- Cross-chain Subgraph Handling: Querying from multiple subgraphs in a single query
- [Automatic Block Tracking](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [Automatic Pagination](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- Fully typed result

`ग्राफ-क्लायंट` सह आलेखाची क्वेरी कशी करायची ते येथे आहे:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

आणखी ग्राफक्यूएल क्लायंट पर्याये ["अनुप्रयोगातून क्वेरी करणे"](/querying/querying-from-an-application) मध्ये कवेऱ्या आहेत.

आता की आपल्याला GraphQL क्वेरीज सिंटॅक्सच्या मूल नियमांची माहिती मिळाली आहे, आपल्याला आता GraphQL क्वेरी लिहायला सर्वोत्तम मार्गदर्शन कसे करण्याची हे पहा.

---

## Writing GraphQL queries

### Always write static queries

एक सामान्य (कुटिम) प्रथा ही आहे की क्वेरी स्ट्रिंग्ज डायनॅमिकली खासगी तयार करणे, या प्रकारे:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

ज्याचा वरील स्निपेट वैध GraphQL क्वेरी तयार करतो, **त्याच्याकडून त्याच्याकिंवा किंवा**तात्पुरत्या गोडक्याच्या वादांची अनेक कमतरता आहेत:

- it makes it **harder to understand** the query as a whole
- developers are **responsible for safely sanitizing the string interpolation**
- विनंती पॅरामीटर्सचा भाग म्हणून व्हेरिएबल्सची मूल्ये पाठवत नाही **सर्व्हर-साइडवर संभाव्य कॅशिंग प्रतिबंधित करा**
- it **prevents tools from statically analyzing the query** (ex: Linter, or type generations tools)

या कारणासाठी, हमेशा क्वेरीजला स्थायी स्ट्रिंग्ज म्हणून लिहण्याची शिफारस केली जाते:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

असे केल्याने **अनेक फायदे** मिळतात:

- **Easy to read and maintain** queries
- The GraphQL **server handles variables sanitization**
- **Variables can be cached** at server-level
- **Queries can be statically analyzed by tools** (more on this in the following sections)

**टीप: स्थिर क्वेरींमध्ये फील्ड सशर्त कसे समाविष्ट करावे**

आपल्याला `owner` फील्ड फक्त एक विशिष्ट शर्ताने समाविष्ट करायचं शक्य आहे.

यासाठी, आपण खासगी `@include(if:...)` निर्देशिकेचा लाभ घेऊ शकता, जसे की खालीलप्रमाणे:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

सूचना: विरुद्ध निर्देशिकेची `@skip(if: ...)` आहे.

### Performance tips

**"काय हवे ते मागा"**

GraphQL त्याच्या "तुम्हाला काय हवे आहे" या टॅगलाइनसाठी प्रसिद्ध झाले.

ही कारणे, GraphQLमध्ये सर्व उपलब्ध फील्ड्स मिळवण्याची कोणतीही प्रक्रिया नाही, त्याच्या एकूणीकरणीतून त्यांची व्यक्तींची यादी किंवा फील्ड्सची यादी दाखवायला हवी.

GraphQL एपीआयव्यूस क्वेरी करताना, नेहमी त्या फील्ड्सची क्वेरी करण्याची विचार करा ज्या खरोखरच वापरल्या जातील.

एक सामान्य अधिक-फेचिंगचा कारण प्राण्याच्या संग्रहांमधील समूहे आहेत. मुलपूर्णपणे, क्वेरीमध्ये आपल्याला 100 प्राण्यांचे संग्रह आपल्याला पूर्वनिर्धारितपणे फेच करतात, ज्याचे सामान्यपणे वापरले जाणार नाही, उदाहरणार्थ, वापरकर्त्याला प्रदर्शित केल्यास. क्वेरीसाठी त्यामुळे पहिल्याच्या उपयुक्तपणे संकेतितपणे सेट केले पाहिजे, आणि सुनिश्चित करावे की आपल्याला आता आवश्यकपणे प्राण्य फेच केले आहेत. ह्या अंतर्गत क्वेरीमध्ये मुख्यपणे संग्रहाच्या संग्रहांसाठी म्हणजे पुढाकटीच्या प्राण्यांच्या संग्रहांसाठी ह्या सिद्धांताचा प्रायः अनुसरण करण्याची आवश्यकता आहे.

उदाहरणार्थ, खालील क्वेरीमध्ये:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

प्रतिसादात 100 टोकन्सप्रती 100 लेनी असू शकतात.

जर अनुप्रयोगाला केवळ 10 लेनीची आवश्यकता आहे तर क्वेरीतील transactions फील्डवर स्पष्टपणे `first: 10` सेट करण्याची आवश्यकता आहे.

**एकाधिक क्वेरी एकत्र करणे**

तुमच्या अनुप्रयोगाला खालीलप्रमाणे विविध प्रकारच्या डेटांची क्वेरी आवश्यक असू शकते:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

ही प्रकल्पना पूर्णपणे वैध आहे, परंतु यात्रेच्या दोन दुऱ्यांसह ग्राफक्यूएल एपीआयव्यूसह आवश्यक आहे.

सुदैवाने, खालीलप्रमाणे एकाच GraphQL विनंतीमध्ये एकाधिक क्वेरी पाठवणे देखील वैध आहे:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

ह्या प्रकारच्या पृष्ठभरयाच्या सापडण्याच्या कामाला कमी करून, **एकूण प्रदर्शनाची दक्षता सुधारणारी** या प्रक्रियेचा पालन करण्याची अपेक्षा आहे (APIला एक फेरी बचवल्यास तुमच्या यात्रेची वळणबळ वजावते) आणि **लघुरूपाची क्रियान्विती** प्रदान करेल.

### Leverage GraphQL Fragments

ग्राफक्यूएल क्वेरी लिहिण्यासाठी मदतकारक सुविधा ग्राफक्यूएल फ्रगमेंट आहे.

खालील क्वेरीपासून पाहताना, आपल्याला दिलेल्या कितीतरी फील्ड्स मल्टिपल सेलेक्शन-सेट्स (`{ ... }`) मध्ये पुन्हा-पुन्हा पुनरावृत्ती केल्या जातात:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

अशी पुनरावृत्ती फील्ड (`id`, `active`, `status`) अनेक समस्या आणतात:

- harder to read for more extensive queries
- प्रश्नांवर आधारित TypeScript प्रकार व्युत्पन्न करणारी साधने वापरताना (_त्यावर शेवटच्या विभागात अधिक_), `newDelegate` आणि `oldDelegate` या दोन वेगळ्या इनलाइनचा परिणाम होईल इंटरफेस.

क्वेरीच्या पुनरावलोकनाच्या संसोधित आवृत्तीसाठी खालीलप्रमाणे असेल:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

GraphQL चा `fragment` वापर करण्याच्या माध्यमातून वाचनस्वतत्रतेत (विशेषतः प्रमाणे मोजण्यास) सुधारणा होईल, तसेच चांगली TypeScript प्रकार संवर्धन होईल.

प्रकार संवर्धन साधन वापरताना, उपरोक्त क्वेरीतून योग्य `DelegateItemFragment` प्रकार उत्पन्न होईल (_आपल्याला "साधने" खंडात पहा_).

### GraphQL Fragment do's and don'ts

**Fragment base must be a type**

एक फ्रगमेंट अप्रयुक्त प्रकारावर आधारित असू शकत नाही, संक्षिप्तपणे, **फील्डस नसलेल्या प्रकारावर**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` हा **स्केलर** (प्राकृतिक "सादे" प्रकार) आहे ज्याचे फ्रगमेंटच्या आधाराचे रूप घेतले जाऊ शकत नाही.

**How to spread a Fragment**

Fragments are defined on specific types and should be used accordingly in queries.

उदाहरण:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` आणि `oldDelegate` हे `Transcoder` प्रकारचे आहेत.

येथे `Vote` प्रकाराच्या फ्रगमेंट प्रसारित करणे संभव नाही.

**फ्रगमेंटला एक पृथक व्यवसायिक डेटा यूनिट म्हणून वर्णन करा**

GraphQL फ्रगमेंटने त्याच्या वापरानुसार परिभाषित केलेले पाहिजे.

अधिकांश वापरक्षमतेसाठी, प्रकारानुसार (पुनरावृत्तीता वापरण्याच्या किंवा प्रकार संवर्धनाच्या संदर्भात) एक फ्रगमेंट प्रति प्रकार परिभाषित करण्याची पर्याप्त आहे.

फ्रगमेंट वापरताना एक सांकेतिक नियम आहे:

- when fields of the same type are repeated in a query, group them in a Fragment
- when similar but not the same fields are repeated, create multiple fragments, ex:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## The essential tools

### GraphQL web-based explorers

तुमच्या अनुप्रयोगात क्वेरीजच्या प्रक्रियेने पारंपारिकपणे चालवू शकता. या कारणासाठी, आपल्याला तुमच्या अनुप्रयोगात त्यांचे जोडण्यापूर्वी त्यांची क्वेरीज चाचण्यासाठी [द ग्राफ एक्स्प्लोरर](https://thegraph.com/explorer)चा वापर करण्याची कुटूंब नको. द ग्राफ एक्स्प्लोरर आपल्याला तुमच्या क्वेरीज चाचण्यासाठी पूर्वनियोजित आहे आणि तुमच्या क्वेरीजची परीक्षण करण्याच्या साठी एक GraphQL प्लेग्राउंड प्रदान करेल.

तुम्‍ही तुमच्‍या क्‍वेरी डीबग/चाचणी करण्‍यासाठी अधिक लवचिक मार्ग शोधत असल्‍यास, इतर समान वेब-आधारित साधने उपलब्‍ध आहेत जसे की [Altair](https://altair.sirmuel.design/) आणि [GrafiQL](https://graphiql-online.com/graphiql).

### GraphQL Linting

वरील उल्लिखित उत्तम प्रथा आणि सिंटॅक्टिक नियमांसोबत समर्थन देण्यासाठी खूपच शिफारस केलेल्या वर्कफ्लो आणि IDE (इंटीग्रेटेड डेव्हलपमेंट यूनिट) टूल्स वापरण्यात येतील, हे महत्वपूर्ण आहे.

**ग्राफक्यूएल ईएसलिंट**

[GraphQL ESLint](https://github.com/dotansimha/graphql-eslint) आपल्याला शून्य प्रयत्नांसह GraphQL उत्तम प्रथांच्या वरती राहण्याची मदत करेल.

["operations-recommended"](https://github.com/dotansimha/graphql-eslint#available-configs) कॉन्फिगरेशन सेटअप हे आवश्यक नियम लागू करेल जसे की:

- `@graphql-eslint/fields-on-correct-type`: is a field used on a proper type?
- `@graphql-eslint/no-unused variables`: should a given variable stay unused?
- and more!

हे आपल्याला **प्लेग्राउंडवर किंवा उत्पादनात क्वेरी चालवून त्यांची परीक्षण केल्याशिवाय ही चूकीची शोधण्याची परवानगी देईल!**!

### IDE plugins

**VSCode and GraphQL**

[GraphQL VSCode एक्सटेंशन](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) आपल्या विकासाच्या कामवापरीक्रियेत एक उत्कृष्ट वाढवा. याच्या माध्यमातून आपल्याला मिळवायला:

- syntax highlighting
- autocomplete suggestions
- validation against schema
- snippets
- go to definition for fragments and input types

आपण `graphql-eslint` वापरत आहात तर [ESLint VSCode एक्सटेंशन](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) आपल्याला आपल्य्या कोडमध्ये दिलेल्या त्रुटी आणि आगाखात्यांची सहीपणे दर्शविण्यासाठी आवश्यक आहे.

**WebStorm/Intellij and GraphQL**

[JS GraphQL प्लगिन](https://plugins.jetbrains.com/plugin/8097-graphql/) आपल्याला GraphQLसह काम करताना आपल्या अनुभवात महत्वपूर्ण परिवर्तन करेल आणि खालीलप्रमाणे प्रदान करतो:

- syntax highlighting
- autocomplete suggestions
- validation against schema
- snippets

या [वेबस्टॉर्म लेख](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) वर अधिक माहिती जी प्लगइनची सर्व मुख्य वैशिष्ट्ये दर्शवते.
