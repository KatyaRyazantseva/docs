---
title: सर्वोत्तम पद्धतींची चौकशी करणे
---

आलेख ब्लॉकचेन वरून डेटा क्वेरी करण्यासाठी विकेंद्रित मार्ग प्रदान करतो.

ग्राफ नेटवर्कचा डेटा GraphQL API द्वारे उघड केला जातो, ज्यामुळे GraphQL भाषेसह डेटाची क्वेरी करणे सोपे होते.

हे पृष्‍ठ तुम्हाला GraphQL भाषेचे अत्यावश्यक नियम आणि GraphQL क्वेरी सर्वोत्तम पद्धतींबद्दल मार्गदर्शन करेल.

---

## GraphQL API क्वेरी करत आहे

### ग्राफक्यूएल क्वेरीचे शरीरशास्त्र

REST API च्या विपरीत, GraphQL API एका स्कीमावर तयार केले जाते जे कोणत्या क्वेरी पूर्ण केल्या जाऊ शकतात हे परिभाषित करते.

उदाहरणार्थ, `टोकन` क्वेरी वापरून टोकन मिळवण्यासाठीची क्वेरी खालीलप्रमाणे दिसेल:

```graphql
qक्वेरी GetToken($id: ID!) {
   टोकन (id: $id) {
     आयडी
     मालक
   }
} uery GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

जे खालील अंदाजे JSON प्रतिसाद देईल (_योग्य `$id` व्हेरिएबल व्हॅल्यू_ पास करताना):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

GraphQL क्वेरी GraphQL भाषा वापरतात, जी [विशिष्टता](https://spec.graphql.org/) वर परिभाषित केली जाते.

वरील `GetToken` क्वेरी अनेक भाषा भागांनी बनलेली आहे (खाली `[...]` प्लेसहोल्डरने बदलली आहे):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

सिंटॅक्टिक करा आणि करू नका याची यादी लांब असताना, ग्राफक्यूएल क्वेरी लिहिताना लक्षात ठेवण्याचे आवश्यक नियम येथे आहेत:

- प्रत्येक `queryName` प्रत्येक ऑपरेशनसाठी फक्त एकदाच वापरले जाणे आवश्यक आहे.
- प्रत्येक `फील्ड` निवडीमध्ये फक्त एकदाच वापरला जाणे आवश्यक आहे (आम्ही `टोकन` अंतर्गत दोनदा `आयडी` क्वेरी करू शकत नाही)
- काही `फील्ड` किंवा क्वेरी (जसे की `टोकन्स`) जटिल प्रकार देतात ज्यांना उप-फील्डची निवड आवश्यक असते. अपेक्षित असताना निवड प्रदान न केल्याने (किंवा अपेक्षित नसताना एक प्रदान करणे - उदाहरणार्थ, `id` वर) त्रुटी वाढवेल. फील्ड प्रकार जाणून घेण्यासाठी, कृपया [द ग्राफ एक्सप्लोरर](/network/explorer) पहा.
- आर्ग्युमेंटला नियुक्त केलेले कोणतेही व्हेरिएबल त्याच्या प्रकाराशी जुळले पाहिजे.
- व्हेरिएबल्सच्या दिलेल्या सूचीमध्ये, त्यापैकी प्रत्येक अद्वितीय असणे आवश्यक आहे.
- सर्व परिभाषित व्हेरिएबल्स वापरणे आवश्यक आहे.

वरील नियमांचे पालन करण्यात अयशस्वी झाल्यास ग्राफ API मधील त्रुटीसह समाप्त होईल.

कोड उदाहरणांसह नियमांच्या संपूर्ण सूचीसाठी, कृपया आमचे GraphQL प्रमाणीकरण मार्गदर्शक पहा.

### GraphQL API वर क्वेरी पाठवत आहे

ग्राफक्यूएल हे एक भाषा आणि HTTP वर परिवहन करण्याच्या साधना सेट आहे.

हे म्हणजे आपण स्टॅंडर्ड `fetch` (प्राकृतिकपणे किंवा `@whatwg-node/fetch` किंवा `isomorphic-fetch`) वापरून ग्राफक्यूएल एपीआयला क्वेरी करू शकता.

परंतु, ["अनुप्रयोगातून क्वेरी करणे"](/querying/querying-from-an-application) मध्ये दिलेल्या निर्देशानुसार, आम्ही आपल्याला आपल्या `graph-client` वापरण्याची सिफार्से देतो ज्यामुळे अनूठी वैशिष्ट्ये समर्थित केलीत जसे कि:

- क्रॉस-चेक्रॉस-चेन सबग्राफ हँडलिंग: एकाच क्वेरीमध्ये एकाधिक सबग्राफमधून क्वेरी करणेन
- [स्वयंचलित ब्लॉक ट्रॅकिंग](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [स्वयंचलित पृष्ठांकन](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- पूर्ण टाईप केलेला निकाल

`ग्राफ-क्लायंट` सह आलेखाची क्वेरी कशी करायची ते येथे आहे:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

आणखी ग्राफक्यूएल क्लायंट पर्याये ["अनुप्रयोगातून क्वेरी करणे"](/querying/querying-from-an-application) मध्ये कवेऱ्या आहेत.

आता की आपल्याला GraphQL क्वेरीज सिंटॅक्सच्या मूल नियमांची माहिती मिळाली आहे, आपल्याला आता GraphQL क्वेरी लिहायला सर्वोत्तम मार्गदर्शन कसे करण्याची हे पहा.

---

## ग्राफक्यूएल क्वेरी लिहित आहे

### नेहमी स्थिर प्रश्न लिहा

एक सामान्य (कुटिम) प्रथा ही आहे की क्वेरी स्ट्रिंग्ज डायनॅमिकली खासगी तयार करणे, या प्रकारे:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

ज्याचा वरील स्निपेट वैध GraphQL क्वेरी तयार करतो, **त्याच्याकडून त्याच्याकिंवा किंवा**तात्पुरत्या गोडक्याच्या वादांची अनेक कमतरता आहेत:

- त्यामुळे संपूर्ण क्वेरी **समजणे कठीण** होते
- विकसक **स्ट्रिंग इंटरपोलेशन सुरक्षितपणे निर्जंतुक करण्यासाठी जबाबदार आहेत**
- विनंती पॅरामीटर्सचा भाग म्हणून व्हेरिएबल्सची मूल्ये पाठवत नाही **सर्व्हर-साइडवर संभाव्य कॅशिंग प्रतिबंधित करा**
- ते **साधनांना क्वेरीचे स्थिर विश्लेषण करण्यापासून प्रतिबंधित करते** (उदा: लिंटर, किंवा जनरेशन टूल्स टाइप करा)

या कारणासाठी, हमेशा क्वेरीजला स्थायी स्ट्रिंग्ज म्हणून लिहण्याची शिफारस केली जाते:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

असे केल्याने **अनेक फायदे** मिळतात:

- **वाचणे आणि देखरेख करणे सोपे** क्वेरी
- GraphQL **सर्व्हर व्हेरिएबल्स सॅनिटायझेशन हाताळतो**
- सर्व्हर-स्तरावर **व्हेरिएबल्स कॅशे केले जाऊ शकतात**
- **प्रश्नांचे साधनांद्वारे स्थिर विश्लेषण केले जाऊ शकते** (याबद्दल पुढील विभागांमध्ये अधिक)

**टीप: स्थिर क्वेरींमध्ये फील्ड सशर्त कसे समाविष्ट करावे**

आपल्याला `owner` फील्ड फक्त एक विशिष्ट शर्ताने समाविष्ट करायचं शक्य आहे.

यासाठी, आपण खासगी `@include(if:...)` निर्देशिकेचा लाभ घेऊ शकता, जसे की खालीलप्रमाणे:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

सूचना: विरुद्ध निर्देशिकेची `@skip(if: ...)` आहे.

### कामगिरी टिपा

**"काय हवे ते मागा"**

GraphQL त्याच्या "तुम्हाला काय हवे आहे" या टॅगलाइनसाठी प्रसिद्ध झाले.

ही कारणे, GraphQLमध्ये सर्व उपलब्ध फील्ड्स मिळवण्याची कोणतीही प्रक्रिया नाही, त्याच्या एकूणीकरणीतून त्यांची व्यक्तींची यादी किंवा फील्ड्सची यादी दाखवायला हवी.

GraphQL एपीआयव्यूस क्वेरी करताना, नेहमी त्या फील्ड्सची क्वेरी करण्याची विचार करा ज्या खरोखरच वापरल्या जातील.

एक सामान्य अधिक-फेचिंगचा कारण प्राण्याच्या संग्रहांमधील समूहे आहेत. मुलपूर्णपणे, क्वेरीमध्ये आपल्याला 100 प्राण्यांचे संग्रह आपल्याला पूर्वनिर्धारितपणे फेच करतात, ज्याचे सामान्यपणे वापरले जाणार नाही, उदाहरणार्थ, वापरकर्त्याला प्रदर्शित केल्यास. क्वेरीसाठी त्यामुळे पहिल्याच्या उपयुक्तपणे संकेतितपणे सेट केले पाहिजे, आणि सुनिश्चित करावे की आपल्याला आता आवश्यकपणे प्राण्य फेच केले आहेत. ह्या अंतर्गत क्वेरीमध्ये मुख्यपणे संग्रहाच्या संग्रहांसाठी म्हणजे पुढाकटीच्या प्राण्यांच्या संग्रहांसाठी ह्या सिद्धांताचा प्रायः अनुसरण करण्याची आवश्यकता आहे.

उदाहरणार्थ, खालील क्वेरीमध्ये:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

प्रतिसादात 100 टोकन्सप्रती 100 लेनी असू शकतात.

जर अनुप्रयोगाला केवळ 10 लेनीची आवश्यकता आहे तर क्वेरीतील transactions फील्डवर स्पष्टपणे `first: 10` सेट करण्याची आवश्यकता आहे.

**एकाधिक क्वेरी एकत्र करणे**

तुमच्या अनुप्रयोगाला खालीलप्रमाणे विविध प्रकारच्या डेटांची क्वेरी आवश्यक असू शकते:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

ही प्रकल्पना पूर्णपणे वैध आहे, परंतु यात्रेच्या दोन दुऱ्यांसह ग्राफक्यूएल एपीआयव्यूसह आवश्यक आहे.

सुदैवाने, खालीलप्रमाणे एकाच GraphQL विनंतीमध्ये एकाधिक क्वेरी पाठवणे देखील वैध आहे:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

ह्या प्रकारच्या पृष्ठभरयाच्या सापडण्याच्या कामाला कमी करून, **एकूण प्रदर्शनाची दक्षता सुधारणारी** या प्रक्रियेचा पालन करण्याची अपेक्षा आहे (APIला एक फेरी बचवल्यास तुमच्या यात्रेची वळणबळ वजावते) आणि **लघुरूपाची क्रियान्विती** प्रदान करेल.

### GraphQL फ्रॅगमेंट्सचा फायदा घ्या

ग्राफक्यूएल क्वेरी लिहिण्यासाठी मदतकारक सुविधा ग्राफक्यूएल फ्रगमेंट आहे.

खालील क्वेरीपासून पाहताना, आपल्याला दिलेल्या कितीतरी फील्ड्स मल्टिपल सेलेक्शन-सेट्स (`{ ... }`) मध्ये पुन्हा-पुन्हा पुनरावृत्ती केल्या जातात:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

अशी पुनरावृत्ती फील्ड (`id`, `active`, `status`) अनेक समस्या आणतात:

- अधिक विस्तृत प्रश्नांसाठी वाचणे कठीण
- प्रश्नांवर आधारित TypeScript प्रकार व्युत्पन्न करणारी साधने वापरताना (_त्यावर शेवटच्या विभागात अधिक_), `newDelegate` आणि `oldDelegate` या दोन वेगळ्या इनलाइनचा परिणाम होईल इंटरफेस.

क्वेरीच्या पुनरावलोकनाच्या संसोधित आवृत्तीसाठी खालीलप्रमाणे असेल:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

GraphQL चा `fragment` वापर करण्याच्या माध्यमातून वाचनस्वतत्रतेत (विशेषतः प्रमाणे मोजण्यास) सुधारणा होईल, तसेच चांगली TypeScript प्रकार संवर्धन होईल.

प्रकार संवर्धन साधन वापरताना, उपरोक्त क्वेरीतून योग्य `DelegateItemFragment` प्रकार उत्पन्न होईल (_आपल्याला "साधने" खंडात पहा_).

### GraphQL फ्रॅगमेंट काय करावे आणि करू नये

**Fragment base must be a type**

एक फ्रगमेंट अप्रयुक्त प्रकारावर आधारित असू शकत नाही, संक्षिप्तपणे, **फील्डस नसलेल्या प्रकारावर**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` हा **स्केलर** (प्राकृतिक "सादे" प्रकार) आहे ज्याचे फ्रगमेंटच्या आधाराचे रूप घेतले जाऊ शकत नाही.

**How to spread a Fragment**

Fragments are defined on specific types and should be used accordingly in queries.

उदाहरण:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` आणि `oldDelegate` हे `Transcoder` प्रकारचे आहेत.

येथे `Vote` प्रकाराच्या फ्रगमेंट प्रसारित करणे संभव नाही.

**फ्रगमेंटला एक पृथक व्यवसायिक डेटा यूनिट म्हणून वर्णन करा**

GraphQL फ्रगमेंटने त्याच्या वापरानुसार परिभाषित केलेले पाहिजे.

अधिकांश वापरक्षमतेसाठी, प्रकारानुसार (पुनरावृत्तीता वापरण्याच्या किंवा प्रकार संवर्धनाच्या संदर्भात) एक फ्रगमेंट प्रति प्रकार परिभाषित करण्याची पर्याप्त आहे.

फ्रगमेंट वापरताना एक सांकेतिक नियम आहे:

- जेव्हा एकाच प्रकारची फील्ड क्वेरीमध्ये पुनरावृत्ती होते, तेव्हा त्यांना एका तुकड्यात गटबद्ध करा
- जेव्हा समान परंतु समान फील्डची पुनरावृत्ती होत नाही, तेव्हा अनेक तुकडे तयार करा, उदा:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## आवश्यक साधने

### ग्राफक्यूएल वेब-आधारित एक्सप्लोरर

तुमच्या अनुप्रयोगात क्वेरीजच्या प्रक्रियेने पारंपारिकपणे चालवू शकता. या कारणासाठी, आपल्याला तुमच्या अनुप्रयोगात त्यांचे जोडण्यापूर्वी त्यांची क्वेरीज चाचण्यासाठी [द ग्राफ एक्स्प्लोरर](https://thegraph.com/explorer)चा वापर करण्याची कुटूंब नको. द ग्राफ एक्स्प्लोरर आपल्याला तुमच्या क्वेरीज चाचण्यासाठी पूर्वनियोजित आहे आणि तुमच्या क्वेरीजची परीक्षण करण्याच्या साठी एक GraphQL प्लेग्राउंड प्रदान करेल.

तुम्‍ही तुमच्‍या क्‍वेरी डीबग/चाचणी करण्‍यासाठी अधिक लवचिक मार्ग शोधत असल्‍यास, इतर समान वेब-आधारित साधने उपलब्‍ध आहेत जसे की [Altair](https://altair.sirmuel.design/) आणि [GrafiQL](https://graphiql-online.com/graphiql).

### ग्राफक्यूएल लिंटिंग

वरील उल्लिखित उत्तम प्रथा आणि सिंटॅक्टिक नियमांसोबत समर्थन देण्यासाठी खूपच शिफारस केलेल्या वर्कफ्लो आणि IDE (इंटीग्रेटेड डेव्हलपमेंट यूनिट) टूल्स वापरण्यात येतील, हे महत्वपूर्ण आहे.

**ग्राफक्यूएल ईएसलिंट**

[GraphQL ESLint](https://github.com/dotansimha/graphql-eslint) आपल्याला शून्य प्रयत्नांसह GraphQL उत्तम प्रथांच्या वरती राहण्याची मदत करेल.

["operations-recommended"](https://github.com/dotansimha/graphql-eslint#available-configs) कॉन्फिगरेशन सेटअप हे आवश्यक नियम लागू करेल जसे की:

- `@graphql-eslint/fields-on-correct-type`: is a field used on a proper type?
- `@graphql-eslint/no-unused variables`: दिलेले व्हेरिएबल वापरलेले नसावे का?
- आणि अधिक!

हे आपल्याला **प्लेग्राउंडवर किंवा उत्पादनात क्वेरी चालवून त्यांची परीक्षण केल्याशिवाय ही चूकीची शोधण्याची परवानगी देईल!**!

### IDE प्लगइन

**VSCode and GraphQL**

[GraphQL VSCode एक्सटेंशन](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) आपल्या विकासाच्या कामवापरीक्रियेत एक उत्कृष्ट वाढवा. याच्या माध्यमातून आपल्याला मिळवायला:

- वाक्यरचना हायलाइटिंग
- स्वयंपूर्ण सूचना
- स्कीमा विरुद्ध प्रमाणीकरण
- स्निपेट्स
- तुकड्या आणि इनपुट प्रकारांसाठी परिभाषा वर जा

आपण `graphql-eslint` वापरत आहात तर [ESLint VSCode एक्सटेंशन](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) आपल्याला आपल्य्या कोडमध्ये दिलेल्या त्रुटी आणि आगाखात्यांची सहीपणे दर्शविण्यासाठी आवश्यक आहे.

**WebStorm/Intellij and GraphQL**

[JS GraphQL प्लगिन](https://plugins.jetbrains.com/plugin/8097-graphql/) आपल्याला GraphQLसह काम करताना आपल्या अनुभवात महत्वपूर्ण परिवर्तन करेल आणि खालीलप्रमाणे प्रदान करतो:

- वाक्यरचना हायलाइटिंग
- स्वयंपूर्ण सूचना
- स्कीमा विरुद्ध प्रमाणीकरण
- स्निपेट्स

या [वेबस्टॉर्म लेख](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) वर अधिक माहिती जी प्लगइनची सर्व मुख्य वैशिष्ट्ये दर्शवते.
