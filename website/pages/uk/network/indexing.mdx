---
title: Індексація
---

Індексатори - це оператори нод у The Graph Network, які стейкають токени Graph (GRT), щоб надавати послуги з індексування та обробки запитів. За свої послуги індексатори отримують плату за запити та винагороду за індексацію. Вони також заробляють комісію за запити, яка повертається відповідно до експоненціальної функції компенсації.

GRT, які застейкані в протоколі, підлягають періоду "розблокування" і можуть бути порізані (slashing), якщо індексатори є шкідливими та надають некоректні дані додаткам або якщо вони неправильно індексують. Індексатори також отримують винагороду за стейк, який вони отримують від делегатів, щоб зробити свій внесок у розвиток мережі.

Індексатори вибирають підграфи для індексування на основі сигналу від кураторів, де куратори стейкають GRT, щоб вказати, які підграфи є якісними та мають бути пріоритетними. Споживачі (наприклад, додатки) також можуть задавати параметри, за якими індексатори обробляють запити до їхніх підграфів, і встановлювати налаштування щодо оплати за запити.

<Difficulty level="ADVANCED" />

## Поширені запитання

### Яка мінімальна кількість GRT необхідна для того, щоб стати індексатором в мережі?

Мінімальна кількість для індексатора наразі встановлена на рівні 100 тис. GRT.

### Які джерела доходу для індексатора?

**Отримання комісії за опрацювання запитів** - Платежі за обслуговування запитів у мережі. Ці платежі здійснюються через відповідні канали між індексатором та сіткою. Кожен запит містить платіж, а відповідна відповідь - доказ правдивості результату запиту.

**Винагорода за індексацію** - Винагорода за індексацію, що генерується шляхом 3% річної інфляції в масштабі всього протоколу, розподіляється серед індексаторів, які індексують розгортання підграфів для мережі.

### Як розподіляються винагороди за індексацію?

Винагорода за індексацію надходить від інфляції протоколу, яка встановлена на рівні 3% річної емісії. Вони розподіляються між підграфами на основі частки всіх кураторських сигналів на кожному, а потім розподіляються пропорційно між індексаторами на основі їхнього виділеного стейку на відповідному підграфі. **Щоб мати право на винагороду, розподіл має бути закрито за допомогою доказу індексації (proof of indexing - POI), яке відповідає стандартам, установленим арбітражним регламентом.**

Спільнота створила численні інструменти для розрахунку винагород; їх колекцію можна знайти в [колекції Community Guides](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c). Ви також можете знайти оновлений список інструментів у каналах #Delegators та #Indexers на [сервері у Discord](https://discord.gg/vtvv7FP). Тут ми зв’язуємо [рекомендований оптимізатор розподілу](https://github.com/graphprotocol/AllocationOpt.jl), інтегрований зі стеком програмного забезпечення індексатора.

### Що за доказ індексації (POI)?

POI використовуються в мережі для перевірки того, що Індексатор індексує підграфи, на які вони були розподілені. POI для першого блоку поточної епохи має бути надісланий при закритті розподілу, щоб цей розподіл мав право на винагороду за індексацію. POI для блоку - це дайджест усіх транзакцій сховища об'єктів для певного розгортання підграфів до цього блоку включно.

### Коли розподіляються винагороди за індексацію?

Винагороди безперервно накопичуються, поки алокації активні та розподілені протягом 28 періодів. Винагороди збираються Індексаторами та розподіляються щоразу, коли їхні розподіли закриваються. Це відбувається або вручну, коли Індексатор хоче примусово закрити їх, або після 28 епох, делегат може закрити розподіл для Індексатора, але це не призводить до отримання винагороди. 28 епох - це максимальний час роботи розподілів (зараз одна епоха триває ~24 години).

### Чи можна відстежувати винагороди за індексацію, що очікують на розгляд?

Контракт RewardsManager має функцію [getRewards](https://github.com/graphprotocol/contracts/blob/master/contracts/rewards/RewardsManager.sol#L317), доступну тільки для читання, яку можна використовувати для перевірки очікуваних винагород для конкретного розподілу.

Багато інформаційних панелей, створених спільнотою, містять очікувані значення винагород, і їх можна легко перевірити вручну, виконавши ці кроки:

1. Надішліть запит на [підграф в основній мережі](https://thegraph.com/hosted-service/subgraph/graphprotocol/graph-network-mainnet), щоб отримати ідентифікатори всіх активних розподілів:

```graphql
запит indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") { { } }) { indexer(id: "<INDEXER_ADDRESS>")
    allocations {
      activeForIndexer {
        allocations { id
          id
        }
      }
    }
  }
}
```

Використовуйте Etherscan для виклику `getRewards()`:

- Перейдіть до [EtherScan інтерфейсу, потім до контракту Rewards](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract)

* Оберіть `getRewards()`:
  - Відкрийте список **10. getRewards**.
  - Введіть **allocationID** у вхідних даних.
  - Натисніть кнопку **Query**.

### Що таке спори (disputes) та де я можу їх переглянути?

Запити індексатора та розподіли можуть бути оскаржені на Graph протягом відповідного періоду оскарження. Цей період варіюється в залежності від типу спору. Для запитів/атестацій вікно спору триває 7 епох, тоді як для розподілів - 56. Після закінчення цих періодів спори не можуть бути відкриті ні проти розподілів, ні проти запитів. При відкритті спору учасник повинен внести депозит у розмірі не менше 10 000 GRT, який буде заблокований до завершення спору і винесення рішення по ній. Fisherman (рибалка) - це будь-який учасник мережі, який відкриває спори.

Спори мають **три** можливих результати, так само як і депозит учасників.

- Якщо спір буде відхилено, GRT, внесений в якості депозиту, буде спалено, а Індексатор не буде порізаний.
- Якщо суперечка буде вирішена внічию, депозит користувача буде повернуто, а індексатора не буде порізано.
- Якщо спір буде задоволено, GRT, внесений учасником, буде повернуто, Індексатора буде порізано, а рибалка отримає 50% від GRT, які були порізані.

Спори можна переглянути в інтерфейсі на сторінці профілю індексатора у вкладці `Disputes`.

### Що за комісії за опрацювання запитів і коли вони розподіляються?

Плата за запити збирається шлюзом і розподіляється між індексаторами згідно з експоненціальною функцією повернень (див. GIP [тут](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162)).

Після закриття розподілу виплати можуть бути отримані індексатором. Після клейму, комісії за запити розподіляються між індексатором та його делегатами на основі зниження цін за запити та експоненціальної функції повернень.

### Що таке query fee cut і indexing reward cut?

Значення `queryFeeCut` і `indexingRewardCut` є параметрами делегування, які Індексатор може встановлювати разом із cooldownBlocks, щоб контролювати розподіл GRT між Індексатором і його Делегатами. Перегляньте останні кроки в розділі [Staking in the Protocol](/network/indexing#stake-in-the-protocol), щоб отримати інструкції щодо встановлення параметрів делегування.

- **queryFeeCut** - відсоток від комісій за опрацювання запитів, який буде розподілено між Індексатором та Делегатами. Якщо цей параметр встановлено на рівні в 95%, індексатор отримає 95% від комісій за запити, зароблених при закритті розподілу, а решта 5% підуть Делегатам.

- **indexingRewardCut** - відсоток від винагород за індексацію, який буде розподілено між Індексатором та Делегатами. Якщо цей параметр встановлено на рівні в 95%, індексатор отримає 95% винагороди за індексацію, коли розподіл буде закрито, а делегати розділять між собою решту 5%.

### Як індексатори знають, які підграфи індексувати?

Індексатори можуть відрізнятися один від одного, застосовуючи передові методи для прийняття рішень щодо індексування підграфів, але для того, щоб дати загальне уявлення, ми обговоримо кілька ключових метрик, які використовуються для оцінки підграфів у мережі:

- **Сигнали від кураторів ** - якщо велика частка від загальної кількості сигналів у мережі припадає на певний підграф, то це є хорошим показником інтересу до цього підграфа, особливо під час фази бутстрапу, коли обсяг запитів зростає.

- **Збори за запити** - Історичні дані про обсяг зборів за запити, зібрані для певного підграфа, є хорошим індикатором майбутнього попиту.

- **Кількість застейканих токенів** - Спостереження за поведінкою інших індексаторів або аналіз пропорцій від загального стейку токенів, виділених на конкретні підграфи, може дозволити індексатору відстежувати попит на запити до підграфів, щоб виявити підграфи, яким мережа довіряє, або підграфи, які можуть показати потребу в більшій кількості токенів.

- **Підграфи без винагороди за індексування** - Деякі підграфи не отримують винагороди за індексування переважно через те, що вони використовують непідтримувані можливості, такі як IPFS, або тому, що вони запитують іншу мережу за межами основної мережі. Ви побачите повідомлення про те, що підграф не генерує винагороду за індексацію.

### Які вимоги до апаратного обладнання?

- **Small** - достатній для початку індексування декількох підграфів, ймовірно, потрібно буде розширити.
- **Standard** - налаштування за замовчуванням, це те, що використовується у прикладі маніфестів розгортання k8s/terraform.
- **Medium** - продуктивний індексатор, що підтримує 100 підграфів і 200-500 запитів на секунду.
- **Large** - підготовлений для індексації всіх підграфів, що використовуються наразі, і обслуговування запитів на відповідний трафік.

| Налаштування | Postgres<br />(CPU) | Postgres<br />(пам'ять в GB) | Postgres<br />(диск у ТБ) | VMs<br />(Центральні CPU) | VMs<br />(пам'ять у ГБ) |
| ------------ |:-------------------------:|:----------------------------------:|:-------------------------------:|:-------------------------------:|:-----------------------------:|
| Small        |             4             |                 8                  |                1                |                4                |              16               |
| Standard     |             8             |                 30                 |                1                |               12                |              48               |
| Medium       |            16             |                 64                 |                2                |               32                |              64               |
| Large        |            72             |                468                 |               3.5               |               48                |              184              |

### Яких основних заходів безпеки повинен дотримуватися індексатор?

- **Operator wallet**. Налаштування гаманця оператора є важливим запобіжним заходом, оскільки він дозволяє Індексатору підтримувати відокремлення між своїми ключами, які контролюють застейкані токени, і тими, які використовуються для щоденних операцій. Інструкції див. у розділі [Stake in Protocol](/network/indexing#stake-in-the-protocol).

- **Firewall** - Публічно доступною має бути лише сервіс-індексатор, і особливу увагу слід приділити блокуванню портів адміністратора і доступу до бази даних: не слід відкривати кінцеву точку JSON-RPC Graph Node (порт за замовчуванням: 8030), кінцеву точку API управління індексатором (порт за замовчуванням: 18000) і кінцеву точку бази даних Postgres (порт за замовчуванням: 5432).

## Інфраструктура

Центром інфраструктури індексатора є Graph Node, яка відстежує індексовані мережі, вибирає і завантажує дані відповідно до визначення підграфів і слугує як [GraphQL API](/about/#how-the-graph-works). Graph Node має бути підключена до кінцевої точки, яка надає дані з кожної проіндексованої мережі; ноди IPFS для отримання даних; бази даних PostgreSQL для їх зберігання; і компонентів індексатора, які полегшують його взаємодію з мережею.

- **PostgreSQL database** - основне сховище для Graph Node, саме тут зберігаються дані підграфів. Сервіс-індексатор та агент також використовують базу даних для зберігання даних каналів стану, моделей витрат, правил індексації та дій з розподілу.

- **Data endpoint** - Для EVM-сумісних мереж Graph Node має бути підключена до кінцевої точки, який надає EVM-сумісний JSON-RPC API. Це може бути як один клієнт, так і більш складне налаштування, яке розподіляє навантаження між кількома. Важливо знати, що певні підграфи потребують особливих можливостей клієнта, таких як режим архівування та/або API відстеження парності.

- **Нода IPFS (версія менше ніж 5)** - метадані розгортання підграфів зберігаються у мережі IPFS. Graph Node звертається до вузла IPFS під час розгортання підграфів, щоб отримати маніфест підграфів і всі пов'язані файли. Індексаторам в мережі не потрібно запускати власну ноду IPFS, ноду IPFS для мережі розміщено на https://ipfs.network.thegraph.com.

- **Indexer service** - виконує всі необхідні зовнішні комунікації з мережею. Обмінюється моделями витрат і статусами індексації, передає запити від шлюзів до Graph Node, а також керує оплатою запитів через відповідні канали зі шлюзом.

- **Indexer agent** - полегшує взаємодію індексаторів в мережі, включаючи реєстрацію у мережі, керування розгортанням підграфів у Graph Node/-ах та керуванням розподілами.

- **Сервер метрик Prometheus** - Компоненти Graph Node та індексаторів реєструють свої метрики на відповідному на сервері.

Примітка: Для підтримки гнучкого масштабування рекомендується розділити завдання запитів та індексації між різними наборами нод: нодами запитів та нодами індексації.

### Огляд портів

> **Важливо**: Будьте обережні з публічним відкриттям портів - **адміністративні порти** слід тримати закритими. Це стосується і JSON-RPC Graph Node та кінцевих точок керування індексатором, описаних нижче.

#### Graph Node

| Порт | Призначення                                               | Розташування                                         | Аргумент CLI      | Перемінна оточення |
| ---- | --------------------------------------------------------- | ---------------------------------------------------- | ----------------- | ------------------ |
| 8000 | HTTP-сервер GraphQL<br />(для запитів до підграфів) | /subgraphs/id/...<br />/subgraphs/name/.../... | --http-порт       | -                  |
| 8001 | GraphQL WS<br />(для підписок на підграфи)          | /subgraphs/id/...<br />/subgraphs/name/.../... | --ws-port         | -                  |
| 8020 | JSON-RPC<br />(для керування розгортаннями)         | /                                                    | --admin-port      | -                  |
| 8030 | API стану індексації підграфів                            | /graphql                                             | --index-node-port | -                  |
| 8040 | Метрики Prometheus                                        | /metrics                                             | --metrics-port    | -                  |

#### Служба індексації

| Порт | Призначення                                                       | Розташування                                                            | Аргумент CLI   | Перемінна оточення     |
| ---- | ----------------------------------------------------------------- | ----------------------------------------------------------------------- | -------------- | ---------------------- |
| 7600 | HTTP-сервер GraphQL<br />(для платних запитів до підграфів) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | --port         | `INDEXER_SERVICE_PORT` |
| 7300 | Метрики Prometheus                                                | /metrics                                                                | --metrics-port | -                      |

#### Агент індексації

| Порт | Призначення                    | Розташування | Аргумент CLI              | Перемінна оточення                      |
| ---- | ------------------------------ | ------------ | ------------------------- | --------------------------------------- |
| 8000 | API для керування індексатором | /            | --indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Налаштування серверної інфраструктури з використанням Terraform на Google Cloud

> Примітка: Індексатори можуть альтернативно використовувати AWS, Microsoft Azure або Alibaba.

#### Встановіть необхідні умови

- Google Cloud SDK
- Kubectl - інструмент командного рядка
- Terraform

#### Створіть проєкт на Google Cloud

- Клонуйте або перейдіть до репозиторію індексатора.

- Перейдіть до каталогу ./terraform, саме тут слід виконати всі команди.

```sh
cd terraform
```

- Авторизуйтесь у Google Cloud і створіть новий проєкт.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Використовуйте сторінку виставлення рахунків у Google Cloud Console, щоб увімкнути виставлення рахунків для нового проєкту.

- Створіть конфігурацію Google Cloud.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- Увімкніть необхідні Google Cloud API.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- Створіть обліковий запис сервісу.

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Get the email of the service account from the list
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- Увімкніть взаємодію між базою даних і кластером Kubernetes, який буде створено на наступному кроці.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- Створіть мінімальний конфігураційний файл terraform (оновлюйте за потреби).

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database passowrd>"
EOF
```

#### Використовуйте Terraform для створення інфраструктури

Перед виконанням будь-яких команд прочитайте [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) і створіть файл `terraform .tfvars` у цьому каталозі (або змініть той, який ми створили на останньому кроці). Для кожної змінної, де ви бажаєте замінити значення за замовчуванням або де вам потрібно встановити значення, введіть параметр у `terraform.tfvars`.

- Запустіть наступні команди, щоб створити інфраструктуру.

```sh
# Встановіть необхідні плагіни
terraform init

# Переглянути план для ресурсів, які будуть створені
terraform plan

# Створіть ресурси (очікується, що це займе до 30 хвилин)
terraform apply
```

Завантажте облікові дані нового кластера до `~/.kube/config` і встановіть його як контекст за замовчуванням.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Створення компонентів Kubernetes для індексатора

- Скопіюйте каталог `k8s/overlays` до нового каталогу `$dir,` і налаштуйте запис `bases` у `$dir/kustomization.yaml< /code>, щоб він вказував на каталог <code>k8s/base`.

- Прочитайте всі файли в `$dir` і змініть будь-які значення, як зазначено в коментарях.

Установіть усі ресурси за допомогою `kubectl apply -k $dir`.

### Graph Node

[Graph Node](https://github.com/graphprotocol/graph-node) - це реалізація Rust з відкритим вихідним кодом, яка використовує події блокчейну Ethereum для детермінованого оновлення сховища даних, які можна запитувати через кінцеву точку GraphQL. Розробники використовують підграфи для визначення своєї схеми та набір відображень для перетворення даних, отриманих з блоків мережі, а Graph Node займається синхронізацією всієї мережі, моніторингом нових блоків і обслуговуванням їх через кінцеву точку GraphQL.

#### Початок роботи з базового коду

#### Встановіть необхідні умови

- **Rust**

- **PostgreSQL**

- **IPFS**

- **Додаткові вимоги для користувачів Ubuntu** - Для запуску Graph Node на Ubuntu може знадобитися декілька додаткових програм.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Налаштування

1. Запуск сервера бази даних PostgreSQL

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. Клонуйте [Graph Node](https://github.com/graphprotocol/graph-node) репозиторій і створіть базовий код, запустивши `cargo build`

3. Тепер, коли всі необхідні складові налаштовано, запустіть Graph Node:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### Початок роботи з Docker

#### Передумови

- **Нода Ethereum**. За замовчуванням, docker compose використовуватиме основну мережу: [http:// host.docker.internal:8545](http://host.docker.internal:8545) для підключення до ноди Ethereum на вашій основній машині. Ви можете замінити це ім’я та Url-адресу мережі, оновивши `docker-compose.yaml`.

#### Налаштування

1. Клонуйте Graph Node і перейдіть до каталогу Docker:

```sh
git clone http://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. Лише для користувачів Linux – використовуйте IP-адресу хоста замість `host.docker.internal` у `docker-compose.yaml` за допомогою доданого скрипта:

```sh
./setup.sh
```

3. Запустіть локальну Graph Node, яка буде підключена до вашої кінцевої точки Ethereum:

```sh
docker-compose up
```

### Компоненти індексатора

To successfully participate in the network requires almost constant monitoring and interaction, so we've built a suite of Typescript applications for facilitating an Indexers network participation. There are three Indexer components:

- **Indexer agent** - The agent monitors the network and the Indexer's own infrastructure and manages which subgraph deployments are indexed and allocated towards on chain and how much is allocated towards each.

- **Indexer service** - The only component that needs to be exposed externally, the service passes on subgraph queries to the graph node, manages state channels for query payments, shares important decision making information to clients like the gateways.

- **Indexer CLI** - The command line interface for managing the Indexer agent. It allows Indexers to manage cost models, manual allocations, actions queue, and indexing rules.

#### Getting started

The Indexer agent and Indexer service should be co-located with your Graph Node infrastructure. There are many ways to set up virtual execution environments for your Indexer components; here we'll explain how to run them on baremetal using NPM packages or source, or via kubernetes and docker on the Google Cloud Kubernetes Engine. If these setup examples do not translate well to your infrastructure there will likely be a community guide to reference, come say hi on [Discord](https://thegraph.com/discord)! Remember to [stake in the protocol](/network/indexing#stake-in-the-protocol) before starting up your Indexer components!

#### From NPM packages

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### From source

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Using docker

- Pull images from the registry

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

Or build images locally from source

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Run the components

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**NOTE**: After starting the containers, the Indexer service should be accessible at [http://localhost:7600](http://localhost:7600) and the Indexer agent should be exposing the Indexer management API at [http://localhost:18000/](http://localhost:18000/).

#### Using K8s and Terraform

See the [Setup Server Infrastructure Using Terraform on Google Cloud](/network/indexing#setup-server-infrastructure-using-terraform-on-google-cloud) section

#### Usage

> **NOTE**: All runtime configuration variables may be applied either as parameters to the command on startup or using environment variables of the format `COMPONENT_NAME_VARIABLE_NAME`(ex. `INDEXER_AGENT_ETHEREUM`).

#### Indexer agent

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Indexer service

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  | pino-pretty
```

#### Indexer CLI

The Indexer CLI is a plugin for [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli) accessible in the terminal at `graph indexer`.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Indexer management using Indexer CLI

The suggested tool for interacting with the **Indexer Management API** is the **Indexer CLI**, an extension to the **Graph CLI**. The Indexer agent needs input from an Indexer in order to autonomously interact with the network on the behalf of the Indexer. The mechanism for defining Indexer agent behavior are **allocation management** mode and **indexing rules**. Under auto mode, an Indexer can use **indexing rules** to apply their specific strategy for picking subgraphs to index and serve queries for. Rules are managed via a GraphQL API served by the agent and known as the Indexer Management API. Under manual mode, an Indexer can create allocation actions using **actions queue** and explicitly approve them before they get executed. Under oversight mode, **indexing rules** are used to populate **actions queue** and also require explicit approval for execution.

#### Usage

The **Indexer CLI** connects to the Indexer agent, typically through port-forwarding, so the CLI does not need to run on the same server or cluster. To help you get started, and to provide some context, the CLI will briefly be described here.

- `graph indexer connect <url>` - Connect to the Indexer management API. Typically the connection to the server is opened via port forwarding, so the CLI can be easily operated remotely. (Example: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - Get one or more indexing rules using `all` as the `<deployment-id>` to get all rules, or `global` to get the global defaults. An additional argument `--merged` can be used to specify that deployment specific rules are merged with the global rule. This is how they are applied in the Indexer agent.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - Set one or more indexing rules.

- `graph indexer rules start [options] <deployment-id>` - Start indexing a subgraph deployment if available and set its `decisionBasis` to `always`, so the Indexer agent will always choose to index it. If the global rule is set to always then all available subgraphs on the network will be indexed.

- `graph indexer rules stop [options] <deployment-id>` - Stop indexing a deployment and set its `decisionBasis` to never, so it will skip this deployment when deciding on deployments to index.

- `graph indexer rules maybe [options] <deployment-id>` — Set the `decisionBasis` for a deployment to `rules`, so that the Indexer agent will use indexing rules to decide whether to index this deployment.

- `graph indexer actions get [options] <action-id>` - Fetch one or more actions using `all` or leave `action-id` empty to get all actions. An additonal argument `--status` can be used to print out all actions of a certain status.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - Queue allocation action

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - Queue reallocate action

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - Queue unallocate action

- `graph indexer actions cancel [<action-id> ...]` - Cancel all action in the queue if id is unspecified, otherwise cancel array of id with space as separator

- `graph indexer actions approve [<action-id> ...]` - Approve multiple actions for execution

- `graph indexer actions execute approve` - Force the worker to execute approved actions immediately

All commands which display rules in the output can choose between the supported output formats (`table`, `yaml`, and `json`) using the `-output` argument.

#### Indexing rules

Indexing rules can either be applied as global defaults or for specific subgraph deployments using their IDs. The `deployment` and `decisionBasis` fields are mandatory, while all other fields are optional. When an indexing rule has `rules` as the `decisionBasis`, then the Indexer agent will compare non-null threshold values on that rule with values fetched from the network for the corresponding deployment. If the subgraph deployment has values above (or below) any of the thresholds it will be chosen for indexing.

For example, if the global rule has a `minStake` of **5** (GRT), any subgraph deployment which has more than 5 (GRT) of stake allocated to it will be indexed. Threshold rules include `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, and `minAverageQueryFees`.

Data model:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

Example usage of indexing rule:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### Actions queue CLI

The indexer-cli provides an `actions` module for manually working with the action queue. It uses the **Graphql API** hosted by the indexer management server to interact with the actions queue.

The action execution worker will only grab items from the queue to execute if they have `ActionStatus = approved`. In the recommended path actions are added to the queue with ActionStatus = queued, so they must then be approved in order to be executed on-chain. The general flow will look like:

- Action added to the queue by the 3rd party optimizer tool or indexer-cli user
- Indexer can use the `indexer-cli` to view all queued actions
- Indexer (or other software) can approve or cancel actions in the queue using the `indexer-cli`. The approve and cancel commands take an array of action ids as input.
- The execution worker regularly polls the queue for approved actions. It will grab the `approved` actions from the queue, attempt to execute them, and update the values in the db depending on the status of execution to `success` or `failed`.
- If an action is successful the worker will ensure that there is an indexing rule present that tells the agent how to manage the allocation moving forward, useful when taking manual actions while the agent is in `auto` or `oversight` mode.
- The indexer can monitor the action queue to see a history of action execution and if needed re-approve and update action items if they failed execution. The action queue provides a history of all actions queued and taken.

Data model:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

Example usage from source:

```bash
indexer indexer actions get all

indexer indexer actions get --status queued

indexer indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

indexer indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

indexer indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

indexer indexer actions cancel

indexer indexer actions approve 1 3 5

indexer indexer actions execute approve
```

Note that supported action types for allocation management have different input requirements:

- `Allocate` - allocate stake to a specific subgraph deployment

  - required action params:
    - deploymentID
    - amount

- `Unallocate` - close allocation, freeing up the stake to reallocate elsewhere

  - required action params:
    - allocationID
    - deploymentID
  - optional action params:
    - poi
    - force (forces using the provided POI even if it doesn’t match what the graph-node provides)

- `Reallocate` - atomically close allocation and open a fresh allocation for the same subgraph deployment

  - required action params:
    - allocationID
    - deploymentID
    - amount
  - optional action params:
    - poi
    - force (forces using the provided POI even if it doesn’t match what the graph-node provides)

#### Cost models

Cost models provide dynamic pricing for queries based on market and query attributes. The Indexer Service shares a cost model with the gateways for each subgraph for which they intend to respond to queries. The gateways, in turn, use the cost model to make Indexer selection decisions per query and to negotiate payment with chosen Indexers.

#### Agora

The Agora language provides a flexible format for declaring cost models for queries. An Agora price model is a sequence of statements that execute in order for each top-level query in a GraphQL query. For each top-level query, the first statement which matches it determines the price for that query.

A statement is comprised of a predicate, which is used for matching GraphQL queries, and a cost expression which when evaluated outputs a cost in decimal GRT. Values in the named argument position of a query may be captured in the predicate and used in the expression. Globals may also be set and substituted in for placeholders in an expression.

Example cost model:

```
# This statement captures the skip value,
# uses a boolean expression in the predicate to match specific queries that use `skip`
# and a cost expression to calculate the cost based on the `skip` value and the SYSTEM_LOAD global
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# This default will match any GraphQL expression.
# It uses a Global substituted into the expression to calculate cost
default => 0.1 * $SYSTEM_LOAD;
```

Example query costing using the above model:

| Query                                                                        | Price   |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#123; tokens &#125; symbol &#125; &#125; | 0.6 GRT |

#### Applying the cost model

Cost models are applied via the Indexer CLI, which passes them to the Indexer Management API of the Indexer agent for storing in the database. The Indexer Service will then pick them up and serve the cost models to gateways whenever they ask for them.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Interacting with the network

### Stake in the protocol

The first steps to participating in the network as an Indexer are to approve the protocol, stake funds, and (optionally) set up an operator address for day-to-day protocol interactions. _ **Note**: For the purposes of these instructions Remix will be used for contract interaction, but feel free to use your tool of choice ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), and [MyCrypto](https://www.mycrypto.com/account) are a few other known tools)._

Once an Indexer has staked GRT in the protocol, the [Indexer components](/network/indexing#indexer-components) can be started up and begin their interactions with the network.

#### Approve tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **GraphToken.abi** with the [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. With `GraphToken.abi` selected and open in the editor, switch to the Deploy and `Run Transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the GraphToken contract address - Paste the GraphToken contract address (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) next to `At Address` and click the `At address` button to apply.

6. Call the `approve(spender, amount)` function to approve the Staking contract. Fill in `spender` with the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) and `amount` with the tokens to stake (in wei).

#### Stake tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **Staking.abi** with the staking ABI.

3. With `Staking.abi` selected and open in the editor, switch to the `Deploy` and `Run Transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the Staking contract address - Paste the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) next to `At Address` and click the `At address` button to apply.

6. Call `stake()` to stake GRT in the protocol.

7. (Optional) Indexers may approve another address to be the operator for their Indexer infrastructure in order to separate the keys that control the funds from those that are performing day to day actions such as allocating on subgraphs and serving (paid) queries. In order to set the operator call `setOperator()` with the operator address.

8. (Optional) In order to control the distribution of rewards and strategically attract Delegators Indexers can update their delegation parameters by updating their indexingRewardCut (parts per million), queryFeeCut (parts per million), and cooldownBlocks (number of blocks). To do so call `setDelegationParameters()`. The following example sets the queryFeeCut to distribute 95% of query rebates to the Indexer and 5% to Delegators, set the indexingRewardCutto distribute 60% of indexing rewards to the Indexer and 40% to Delegators, and set `thecooldownBlocks` period to 500 blocks.

```
setDelegationParameters(950000, 600000, 500)
```

### The life of an allocation

After being created by an Indexer a healthy allocation goes through four states.

- **Active** - Once an allocation is created on-chain ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/master/contracts/staking/Staking.sol#L873)) it is considered **active**. A portion of the Indexer's own and/or delegated stake is allocated towards a subgraph deployment, which allows them to claim indexing rewards and serve queries for that subgraph deployment. The Indexer agent manages creating allocations based on the Indexer rules.

- **Closed** - An Indexer is free to close an allocation once 1 epoch has passed ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/master/contracts/staking/Staking.sol#L873)) or their Indexer agent will automatically close the allocation after the **maxAllocationEpochs** (currently 28 days). When an allocation is closed with a valid proof of indexing (POI) their indexing rewards are distributed to the Indexer and its Delegators (see "how are rewards distributed?" below to learn more).

Indexers are recommended to utilize offchain syncing functionality to sync subgraph deployments to chainhead before creating the allocation on-chain. This feature is especially useful for subgraphs that may take longer than 28 epochs to sync or have some chances of failing undeterministically.
