---
title: Integrating New Networks
---

Graph Node can currently index data from the following chain types:

-   Ethereum, via EVM JSON-RPC and [Ethereum Firehose](https://github.com/streamingfast/firehose-ethereum)
-   NEAR, via a [NEAR Firehose](https://github.com/streamingfast/near-firehose-indexer)
-   Cosmos, via a [Cosmos Firehose](https://github.com/graphprotocol/firehose-cosmos)
-   Arweave, via an [Arweave Firehose](https://github.com/graphprotocol/firehose-arweave)

अगर आप इनमें से किसी भी चेन के बारे में रुचि रखते हैं, तो संकलन ग्राफ नोड कॉन्फ़िगरेशन और परीक्षण की प्रक्रिया होती है।

If you are interested in a different chain type, a new with Graph Node must be built. Our recommended approach is developing a new Firehose for the chain in question and then the integration of that Firehose with Graph Node. More info below.

**1. EVM JSON-RPC**

If the blockchain is EVM equivalent and the client/node exposes the standard EVM JSON-RPC API, Graph Node should be able to index the new chain. For more information, refer to [Testing an EVM JSON-RPC](new-chain-integration#testing-an-evm-json-rpc).

**2. Firehose**

For non-EVM-based chains, Graph Node must ingest blockchain data via gRPC and known type definitions. This can be done via [Firehose](firehose/), a new technology developed by [StreamingFast](https://www.streamingfast.io/) that provides a highly-scalable indexing blockchain solution using a files-based and streaming-first approach. Reach out to the [StreamingFast team](mailto:integrations@streamingfast.io) if you need help with Firehose development.

## ईवीएम JSON-RPC और फ़ायरहोज़ के बीच अंतर

While the two are suitable for subgraphs, a Firehose is always required for developers wanting to build with [Substreams](substreams/), like building [Substreams-powered subgraphs](cookbook/substreams-powered-subgraphs/). In addition, Firehose allows for improved indexing speeds when compared to JSON-RPC.

New EVM chain integrators may also consider the Firehose-based approach, given the benefits of substreams and its massive parallelized indexing capabilities. Supporting both allows developers to choose between building substreams or subgraphs for the new chain.

> **NOTE**: A Firehose-based integration for EVM chains will still require Indexers to run the chain's archive RPC node to properly index subgraphs. This is due to the Firehose's inability to provide smart contract state typically accessible by the `eth_call` RPC method. (It's worth reminding that eth_calls are [not a good practice for developers](https://thegraph.com/blog/improve-subgraph-performance-reduce-eth-calls/))

* * *

## एक ईवीएम JSON-RPC का परीक्षण

ग्राफ नोड को डेटा को EVM चेन से स्वागत करने के लिए, आरपीसी नोड को निम्नलिखित EVM JSON RPC मेथड्स का प्रकट करना चाहिए:

-   `eth_getLogs`
-   `eth_call` \_(for historical blocks, with EIP-1898 - requires archive node):
-   `eth_getBlockByNumber`
-   `eth_getBlockByHash`
-   `net_version`
-   `eth_getTransactionReceipt`, in a JSON-RPC batch request
-   _`trace_filter`_ _(optionally required for Graph Node to support call handlers)_

### ग्राफ़ नोड कॉन्फ़िगरेशन

**अपने स्थानीय पर्यावरण को तैयार करके शुरू करें**

1.  [Clone Graph Node](https://github.com/graphprotocol/graph-node)
2.  नए नेटवर्क नाम और ईवीएम JSON RPC अनुरूप URL को शामिल करने के लिए [इस पंक्ति] \(https://github.com/graphprotocol/graph-node/blob/master/docker/docker-compose.yml#L22) को संशोधित करें
    > कृपया पर्यावरण चर ethereum को खुद नाम में बदलें नहीं। यही रहना चाहिए, चाहे नेटवर्क का नाम भिन्न हो।
3.  एक IPFS नोड चलाएं या उसे The Graph द्वारा उपयोग किया जाने वाले वाले वाले नोड का उपयोग करें: https://api.thegraph.com/ipfs/

**Test the integration by locally deploying a subgraph**

1.  [graph-cli] स्थापित करें(https://github.com/graphprotocol/graph-cli)
2.  एक साधारण उदाहरण सबग्राफ बनाएं। कुछ विकल्प निम्नलिखित हैं:
    1.  प्री-पैक्ड [Gravitar](https://github.com/graphprotocol/example-subgraph/tree/f89bdd4628efa4badae7367d4919b3f648083323) स्मार्ट कॉन्ट्रैक्ट और सबग्राफ एक अच्छा शुरुआती बिंदु है
    2.  किसी भी मौजूदा स्मार्ट कॉन्ट्रैक्ट या सॉलिडिटी डेव वातावरण से एक स्थानीय सबग्राफ को बूटस्ट्रैप करें [using Hardhat with a Graph plugin](https://github.com/graphprotocol/hardhat-graph)
3.  परिणामी `subgraph.yaml` को [`dataSources.network`](http://dataSources.network) को उसी नाम में बदलकर अनुकूलित करें जो पहले ग्राफ़ नोड पर दिया गया था।
4.  ग्राफ़ नोड में अपना सबग्राफ बनाएं: `ग्राफ $SUBGRAPH_NAME --नोड $GRAPH_NODE_ENDPOINT बनाएं`
5.  अपने सबग्राफ को ग्राफ नोड पर प्रकाशित करें: graph deploy $SUBGRAPH_NAME --ipfs $IPFS_ENDPOINT --node $GRAPH_NODE_ENDPOINT

ग्राफ नोड को डिप्लॉय किए गए सबग्राफ को सिंक करना चाहिए अगर कोई त्रुटियाँ नहीं हैं। उसे सिंक करने के लिए समय दें, और फिर लॉग में प्रिंट किए गए API एंडप्वाइंट पर कुछ जीक्यूएल क्वेरीज़ भेजें।

* * *

## एक नए फायरहोस-सक्षम चेन को एकीकरण करना:

नए चेन को एकीकरण करना फायरहोस दृष्टिकोण से भी संभव है। यह वर्तमान में गैर-ईवीएम चेनों के लिए सर्वोत्तम विकल्प है और सबस्ट्रीम समर्थन के लिए एक आवश्यकता है। अतिरिक्त दस्तावेज़ीकरण फायरहोस काम कैसे करता है, नए चेन के लिए फायरहोस समर्थन को कैसे जोड़ा जाता है और इसे ग्राफ नोड के साथ एकीकरण करने के बारे में केंद्रित है। एकीकरणकर्ताओं के लिए सिफारिशित दस्तावेज़ीकरण:

1.  [General docs on Firehose](firehose/)
2.  [Adding Firehose support for a new chain](https://firehose.streamingfast.io/integrate-new-chains/integration-overview)
3.  [Integrating Graph Node with a new chain via Firehose](https://github.com/graphprotocol/graph-node/blob/master/docs/implementation/add-chain.md)
