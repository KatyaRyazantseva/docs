---
title: सर्वोत्तम प्रथाओं को क्वेरी करना
---

ग्राफ़ ब्लॉकचेन से डेटा क्वेरी करने के लिए विकेंद्रीकृत तरीका प्रदान करता है।

ग्राफ़ नेटवर्क के डेटा को ग्राफ़िकल एपीआई के माध्यम से उजागर किया जाता है, जिससे ग्राफ़िकल भाषा के साथ डेटा को क्वेरी करना आसान हो जाता है।

यह पृष्ठ आवश्यक ग्राफ़िकल भाषा नियमों और ग्राफ़कॉल प्रश्नों के सर्वोत्तम अभ्यासों के माध्यम से आपका मार्गदर्शन करेगा।

---

## ग्राफ़कॉल एपीआई को क्वेरी करना

### एक ग्राफक्यूएल क्वेरी की शारीरिक रचना

REST API के विपरीत, एक रेखांकन API एक स्कीमा पर बनाया गया है जो परिभाषित करता है कि कौन से प्रश्न किए जा सकते हैं।

उदाहरण के लिए, `token` क्वेरी का उपयोग करके टोकन प्राप्त करने के लिए एक क्वेरी इस प्रकार दिखाई देगी:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

जो निम्नलिखित अनुमानित JSON प्रतिक्रिया लौटाएगा (_उचित `$id` चर मान_ पास करते समय):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

ग्राफ़िकल क्वेरीज़ ग्राफ़िकल भाषा का उपयोग करती हैं, जिसे [एक विनिर्देश](https://spec.graphql.org/) पर परिभाषित किया गया है।

उपरोक्त `GetToken` क्वेरी कई भाषा भागों से बना है (नीचे `[...]` प्लेसहोल्डर्स के साथ प्रतिस्थापित):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

जबकि सिंटैक्टिक डू और डॉनट्स की सूची लंबी है, ग्राफक्यूएल प्रश्नों को लिखते समय ध्यान में रखने के लिए आवश्यक नियम यहां दिए गए हैं:

- प्रत्येक `क्वेरीनाम` का उपयोग प्रति ऑपरेशन केवल एक बार किया जाना चाहिए।
- प्रत्येक `फ़ील्ड` का चयन में केवल एक बार उपयोग किया जाना चाहिए (हम `आईडी` को `टोकन` के अंतर्गत दो बार क्वेरी नहीं कर सकते हैं)
- कुछ `फ़ील्ड`एस या क्वेरीज़ (जैसे `टोकन`) जटिल प्रकार लौटाते हैं जिन्हें उप-फ़ील्ड के चयन की आवश्यकता होती है। अपेक्षित होने पर चयन प्रदान नहीं करना (या अपेक्षा न होने पर चयन प्रदान करना - उदाहरण के लिए, `id` पर) एक त्रुटि उत्पन्न करेगा। किसी फ़ील्ड प्रकार को जानने के लिए, कृपया [द ग्राफ़ एक्सप्लोरर](/network/explorer) देखें।
- किसी तर्क को असाइन किया गया कोई भी चर उसके प्रकार से मेल खाना चाहिए।
- चरों की दी गई सूची में, उनमें से प्रत्येक अद्वितीय होना चाहिए।
- सभी परिभाषित चर का उपयोग किया जाना चाहिए।

उपरोक्त नियमों का पालन करने में विफल रहने पर ग्राफ़ एपीआई की त्रुटि समाप्त हो जाएगी।

कोड उदाहरणों के साथ नियमों की पूरी सूची के लिए, कृपया हमारे ग्राफक्यूएल सत्यापन गाइड को देखें।

### एक ग्राफ़क्यूएल एपीआई के लिए एक प्रश्न भेजना

जीक्यूएल एक भाषा और समझौतों का सेट है जो एचटीटीपी के माध्यम से परिवहन होते हैं।

इसका मतलब है कि आप मानक `fetch` का उपयोग करके (नेटिव रूप से या `@whatwg-node/fetch` या `isomorphic-fetch` के माध्यम से) एक जीक्यूएल एपीआई को क्वेरी कर सकते हैं।

हालांकि, ["एप्लिकेशन से क्वेरी करना"](/querying/querying-from-an-application) में उल्लिखित है कि हम आपको हमारे `graph-client` का उपयोग करने की सिफारिश करते हैं जो ऐसी अनूठी सुविधाओं का समर्थन करता है जैसे:

- क्रॉस-चेन सबग्राफ हैंडलिंग: एक ही क्वेरी में कई सबग्राफ से पूछताछ
- [स्वचालित ब्लॉक ट्रैकिंग](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [स्वचालित पृष्ठांकन](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- पूरी तरह से टाइप किया गया परिणाम

यहाँ है कि `graph-client` का उपयोग करके The Graph को कैसे क्वेरी करें:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

और अधिक जीक्यूएल क्लाइंट विकल्पों को ["एप्लिकेशन से क्वेरी करना"](/querying/querying-from-an-application) में शामिल किया गया है।

अब जब हमने जीक्यूएल क्वेरी की सिंटेक्स के मूल नियमों को कवर किया है, आइए अब जीक्यूएल क्वेरी लेखन की सर्वोत्तम प्रैक्टिस की दिशा में देखें।

---

## ग्राफ़क्यूएल प्रश्न लिखना

### हमेशा स्टैटिक क्वेश्चन लिखें

एक सामान्य (बुरी) प्रैक्टिस यह है कि क्वेरी स्ट्रिंग्स को डाइनामिक रूप से निम्नलिखित तरीके से बनाना:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`
```

जबकि ऊपर की छवि मान्य जीक्यूएल क्वेरी उत्पन्न करती है, **इसमें कई दुष्प्रभाव हैं**:

- यह संपूर्ण क्वेरी को **समझने में कठिन** बनाता है
- डेवलपर **स्ट्रिंग इंटरपोलेशन को सुरक्षित रूप से साफ़ करने के लिए ज़िम्मेदार हैं**
- अनुरोध पैरामीटर ** सर्वर-साइड पर संभावित कैशिंग को रोकें** के हिस्से के रूप में चर के मान नहीं भेज रहे हैं
- यह **टूल्स को क्वेरी का स्थिर रूप से विश्लेषण करने से रोकता है** (उदा: लिंटर, या टाइप जेनरेशन टूल्स)

इस कारण से, सदा क्वेरीज को स्थिर स्ट्रिंग्स के रूप में लिखने की सिफारिश की जाती है:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

ऐसा करने से **कई फायदे** होते हैं:

- **पढ़ने और बनाए रखने में आसान** क्वेरीज़
- ग्राफ़क्यूएल **सर्वर वेरिएबल सैनिटाइज़ेशन को हैंडल करता है**
- सर्वर-स्तर पर **वैरिएबल को कैश किया जा सकता है**
- **क्वेरी का सांख्यिकीय रूप से विश्लेषण टूल द्वारा किया जा सकता है** (निम्न अनुभागों में इस पर अधिक)

**नोट: स्थिर क्वेरीज में फील्ड्स को शर्तानुसार शामिल कैसे करें**

हमें `owner` फील्ड को केवल एक विशेष शर्त पर शामिल करना चाह सकते हैं।

यासाठी, आम्ही खालीलप्रमाणे `@include(if:...)` निर्देशाचा फायदा घेऊ शकतो:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

टीप: उलट निर्देश `@skip(if: ...)` आहे.

### प्रदर्शन युक्तियाँ

**"वह पूछें जो आप चाहते हैं"**

जीक्यूएल ने अपने "वह पूछें जो आप चाहते हैं" टैगलाइन के लिए प्रसिद्ध हुआ।

इस कारण, जीक्यूएल में सभी उपलब्ध फ़ील्ड्स को व्यक्तिगत रूप से सूचीबद्ध किए बिना प्राप्त करने का कोई तरीका नहीं है।

जीक्यूएल एपीआई क्वेरी करते समय, हमेशा वो फ़ील्ड्स की क्वेरी करने की सोचें जो वास्तव में प्रयुक्त होंगे।

अधिक-लानी का एक सामान्य कारण संग्रहित इकाइयों का होता है। डिफ़ॉल्ट रूप से, क्वेरी में एक संग्रह में 100 इकाइयाँ लानी जाएगी, जो आमतौर पर उनकी वास्तविकता से बहुत अधिक होता है, उदाहरण के लिए, उपयोगकर्ता को प्रदर्शित करने के लिए। क्वेरी को इसलिए लगभग हमेशा स्पष्ट रूप से पहले सेट करना चाहिए, और सुनिश्चित करना चाहिए कि वे केवल उन्हें प्राप्त करें जितने इकाइयाँ वास्तव में आवश्यक हो। यह केवल क्वेरी में शीर्ष-स्तर की संग्रहों के लिए ही नहीं है, बल्कि इसे और भी अधिक संग्रहित इकाइयों के नेस्टेड संग्रहों के लिए भी लागू होता है।

उदाहरण के लिए, निम्नलिखित क्वेरी में:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

प्रतिक्रिया में प्रत्येक 100 टोकन के लिए 100 लेन-देन हो सकते हैं।

अगर एप्लिकेशन को केवल 10 लेन-देन की आवश्यकता होती है, तो क्वेरी को स्पष्ट रूप से `first: 10` को लेन-देन फ़ील्ड पर सेट करना चाहिए।

**एकाधिक क्वेरीज को कम्बाइन करना**

आपकी एप्लिकेशन को निम्नलिखित तरीके से कई प्रकार के डेटा क्वेरी करने की आवश्यकता हो सकती है:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

हालांकि यह विन्यास पूरी तरह से मान्य है, इसके लिए जीक्यूएल एपीआई के साथ दो बार यात्रा की आवश्यकता होगी।

भाग्यवश, एक ही GraphQL अनुरोध में एकाधिक क्वेरीज भेजना भी निम्नलिखित तरीके से मान्य है:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

यह दृष्टिकोण **कुल प्रदर्शन को बेहतर बनाएगा** जिससे नेटवर्क पर बिताए जाने वाले समय को कम किया जाएगा (एपीआई के लिए एक यात्रा की बचत होगी) और एक **संक्षिप्त विन्यास** प्रदान करेगा।

### लीवरेज ग्राफक्यूएल फ़्रैगमेंट

जीक्यूएल क्वेरी लिखने के लिए एक सहायक सुविधा है जिसे जीक्यूएल फ्रैगमेंट कहा जाता है।

निम्नलिखित क्वेरी की ओर देखते हुए, आपको यह दिखाई देगा कि कुछ फ़ील्ड्स कई सेलेक्शन-सेट (`{ ... }`) में दोहराए गए हैं:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

इस प्रकार के दोहराए गए फ़ील्ड (`id`, `active`, `status`) कई समस्याएं लाते हैं:

- अधिक व्यापक प्रश्नों के लिए पढ़ना कठिन है
- प्रश्नों के आधार पर टाइपस्क्रिप्ट प्रकार उत्पन्न करने वाले टूल का उपयोग करते समय (_उस पर अधिक पिछले खंड में_), `newDelegate` और `oldDelegate` के परिणामस्वरूप दो अलग-अलग इनलाइन होंगे इंटरफेस।

क्वेरी का एक पुनर्निर्मित संस्करण निम्नलिखित हो सकता है:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

जीक्यूएल `fragment` का उपयोग पठनीयता को सुधारेगा (विशेषकर बड़े स्तर पर) लेकिन यह भी बेहतर टाइपस्क्रिप्ट प्रकार उत्पन्न करेगा।

जब आप टाइप्स जनरेशन टूल का उपयोग करते हैं, ऊपर की क्वेरी एक उचित `DelegateItemFragment` टाइप उत्पन्न करेगी (_अंतिम "उपकरण" अनुभाग देखें_)।

### ग्राफकॉल फ्रैगमेंट क्या करें और क्या न करें

**फ्रॅगमेंट बेस एक प्रकार असणे आवश्यक आहे**

संक्षेप में, एक फ़्रैगमेंट किसी नायायक प्रकार पर नहीं आधारित हो सकता, यानि, **फ़ील्ड न होने वाले प्रकार पर**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` एक **स्केलर** (देशी "सादा" प्रकार) है जिसे फ़्रैगमेंट के आधार के रूप में उपयोग नहीं किया जा सकता है।

**फ्रैगमेंट को कैसे प्रसारित करें:**

फ्रैगमेंट्स विशिष्ट प्रकारों पर परिभाषित किए जाते हैं और क्वेरियों में उनका उपयोग उनके अनुसार होना चाहिए।

उदाहरण:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`नवीन प्रतिनिधी` आणि `ओल्ड डेलिगेट` हे `ट्रान्सकोडर` प्रकारचे आहेत.

यहाँ एक `Vote` प्रकार के फ्रैगमेंट को प्रसारित करना संभव नहीं है।

**फ्रैगमेंट को डेटा की एक पृथ्वीय व्यावसायिक इकाई के रूप में परिभाषित करें।**

जीक्यूएल फ्रैगमेंट को उनके उपयोग के आधार पर परिभाषित किया जाना चाहिए।

अधिकांश यूज-केस के लिए, एक प्रकार पर एक फ्रैगमेंट परिभाषित करना काफी होता है (जब दोहराए गए फ़ील्ड का उपयोग या प्रकार जनरेशन के मामले में)।

यहाँ एक नियम है जिसे फ्रैगमेंट का उपयोग करते समय ध्यान में रख सकते हैं:

- जब किसी क्वेरी में एक ही प्रकार के फ़ील्ड दोहराए जाते हैं, तो उन्हें एक फ़्रैगमेंट में समूहित करें
- जब समान लेकिन समान फ़ील्ड दोहराए जाते हैं, तो एकाधिक टुकड़े बनाएं, उदा:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## आवश्यक उपकरण

### ग्राफक्यूएल वेब-आधारित खोजकर्ता

अपने एप्लिकेशन में क्वेरियों को चलाकर उन पर यात्रा करना कठिन हो सकता है। इस कारण से, अपने एप्लिकेशन में उन्हें जोड़ने से पहले [द ग्राफ एक्सप्लोरर](https://thegraph.com/explorer) का उपयोग करके आपके क्वेरियों का परीक्षण करने में हिचकिचाहट न करें। ग्राफ एक्सप्लोरर आपको एक पूर्व-कॉन्फ़िगर ग्राफक्यूएल प्लेग्राउंड प्रदान करेगा जिसका उपयोग आपके क्वेरियों का परीक्षण करने के लिए कर सकेंगे।

यदि आप अपने प्रश्नों को डीबग/परीक्षण करने के लिए अधिक लचीले तरीके की तलाश में हैं, तो अन्य समान वेब-आधारित उपकरण उपलब्ध हैं जैसे [Altair](https://altair.sirmuel.design/) और [ग्राफीक्यूएल](https://graphiql-online.com/graphiql)।

### ग्राफक्यूएल लाइनिंग

उपरोक्त उत्तम प्रैक्टिस और वाक्यात्मक नियमों के साथ कदम मिलाने के लिए निम्नलिखित वर्कफ़्लो और आईडी उपकरणों का प्रयोग करना काफी सिफारिश किया जाता है।

**ग्राफक्यूएल ईएसलिंट**

[GraphQL ESLint](https://github.com/dotansimha/graphql-eslint) तुम्हाला शून्य प्रयत्नांशिवाय GraphQL सर्वोत्तम सरावांमध्ये शीर्षस्थानी राहण्यास मदत करेल.

["operations-recommended"](https://github.com/dotansimha/graphql-eslint#available-configs) कॉन्फिगरेशन सेटअप हे आवश्यक नियम लागू करेल जसे की:

- `@graphql-eslint/fields-on-correct-type`: क्या फ़ील्ड उचित प्रकार पर उपयोग की जाती है?
- `@graphql-eslint/no-unused वेरिएबल्स`: क्या एक दिया गया वेरिएबल अप्रयुक्त रहना चाहिए?
- और अधिक!

इससे आपको **क्वेरीज को प्लेग्राउंड पर टेस्ट करने या प्रोडक्शन में चलाने की आवश्यकता नहीं होगी, और आप त्रुटियों को पकड़ सकेंगे!**

### आईडीई प्लगइन्स

**VSCode and GraphQL**

[GraphQL VSCode extension](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) आपके विकास वर्कफ़्लो में एक श्रेष्ठ योगदान है जिसके माध्यम से आप प्राप्त कर सकते हैं:

- वाक्य - विन्यास पर प्रकाश डालना
- स्वत: पूर्ण सुझाव
- स्कीमा के खिलाफ सत्यापन
- snippets
- अंशों और इनपुट प्रकारों के लिए परिभाषा पर जाएं

अगर आप `graphql-eslint` का उपयोग कर रहे हैं, तो [ESLint VSCode एक्सटेंशन](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) आपके कोड में सही तरीके से इनलाइन में त्रुटियों और चेतावनियों को दिखाने के लिए अत्यंत आवश्यक है।

**WebStorm/Intellij and GraphQL**

[JS GraphQL प्लगइन](https://plugins.jetbrains.com/plugin/8097-graphql/) आपके GraphQL के साथ काम करते समय आपके अनुभव को काफी सुधारेगा और निम्नलिखित प्रदान करेगा:

- वाक्य - विन्यास पर प्रकाश डालना
- स्वत: पूर्ण सुझाव
- स्कीमा के खिलाफ सत्यापन
- snippets

इस [WebStorm लेख](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) पर अधिक जानकारी मिलेगी जिसमें प्लगइन की सभी मुख्य विशेषताएँ प्रदर्शित की गई हैं।
