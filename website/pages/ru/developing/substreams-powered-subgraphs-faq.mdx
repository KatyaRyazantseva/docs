---
title: Часто задаваемые вопросы о субграфах, работающих на основе субпотоков (Substreams)
---

## Что такое субпотоки?

Субпотоки, разработанные [StreamingFast]\(https://www.streamingfast.io /), представляют собой исключительно мощный механизм обработки, способный потреблять обширные потоки блокчейн-данных. Субпотоки позволяют уточнять и формировать данные блокчейна для быстрого и беспрепятственного использования приложениями конечных пользователей. Более конкретно, Субпотоки - это независимый от блокчейна, распараллеленный и ориентированный на потоковую передачу движок, служащий уровнем преобразования данных блокчейна. Работая на базе [Firehose](https://firehose.streamingfast.io), он позволяет разработчикам писать модули Rust, использовать модули сообщества, обеспечивать чрезвычайно высокопроизводительную индексирование и [sink](/substreams/developers-guide/sink-targets/README/#substreams-sinks-overview) своих данных где угодно.

Перейдите в [Substreams Documentation](/substreams/README/), чтобы узнать больше о Субпотоках.

## Что такое субграфы, работающие на основе Субпотоков?

[Субграфы, работающие на основе Субпотоков](/cookbook/substreams-powered-subgraphs/) сочетают в себе мощь Субпотоков с возможностью запроса субграфов. При публикации Субграфа, работающего на основе Субпотоков, данные, полученные в результате преобразований Субпотоков, могут [выводить изменения объекта](https://github.com/streamingfast/substreams-sink-entity-changes/blob/develop/substreams-entity-change/src/tables.rs), совместимые с объектами субграфа.

Если Вы уже знакомы с разработкой субграфов, обратите внимание на то, что к тому же можно запрашивать субграфы, работающие на основе Субпотоков, точно так же, как если бы они были созданы на уровне преобразования AssemblyScript, со всеми преимуществами Субграфа, такими как предоставление динамического и гибкого GraphQL API.

## Чем субграфы, работающие на основе Субпотоков, отличаются от субграфов?

Субграфы состоят из источников данных, которые определяют события в цепочке и то, как эти события должны быть преобразованы с помощью обработчиков, написанных на Assemblyscript. Эти события обрабатываются последовательно в зависимости от того, в каком порядке события происходят в цепочке.

Напротив, субграфы, работающие на основе субпотоков, имеют один источник данных, который ссылается на пакет субпотоков, обрабатываемый the Graph Node. Субпотоки имеют доступ к дополнительным детализированным данным в цепочке по сравнению с обычными субграфами, а также могут извлекать выгоду из массового распараллеливания обработки, что может подразумевать гораздо более быстрое время обработки.

## Каковы преимущества использования субграфов, работающих на основе Субпотоков?

Субграфы, работающие на основе Субпотоков, сочетают в себе все преимущества Субпотоков с возможностью запроса субграфов. Они обеспечивают большую компонуемость и высокопроизводительную индексацию The Graph. Они также позволяют создавать новые варианты использования данных; например, после того, как Вы создали свой субграф на базе Субпотоков, Вы можете повторно использовать свои [модули Субпотоков](/substreams/developers-guide/creating-your-manifest/#module-definitions) для вывода в разные [sinks](/substreams/developers-guide/sink-targets/#substreams-sinks-overview), такие как PostgreSQL, MongoDB и Kafka.

## В чем преимущества Субпотоков?

Использование Субпотоков имеет много преимуществ, в том числе:

-   Компонуемость: Вы можете объединять модули Субпотоков, как блоки LEGO, и опираться на модули сообщества, дополнительно уточняя общедоступные данные.

-   Высокопроизводительное индексирование: индексирование на порядки быстрее благодаря крупномасштабным кластерам параллельных операций (как пример, BigQuery).

-   Возможность загружать куда угодно: Загружайте Ваши данные в любое удобное для Вас место: PostgreSQL, MongoDB, Kafka, субграфы, плоские файлы, Google Sheets.

-   Программируемость: Используйте код для настройки извлечения, выполнения агрегирования во время преобразования и моделирования выходных данных для нескольких приемников.

-   Доступ к дополнительным данным, недоступным в составе JSON RPC

-   Все преимущества Firehose.

## Что такое Firehose?

Developed by [StreamingFast](https://www.streamingfast.io/), the Firehose is a blockchain data extraction layer designed from scratch to process the full history of blockchains at speeds that were previously unseen. Providing a files-based and streaming-first approach, it is a core component of StreamingFast's suite of open-source technologies and the foundation for Substreams.

Go to the [documentation](https://firehose.streamingfast.io/) to learn more about the Firehose.

## What are the benefits of the Firehose?

There are many benefits to using Firehose, including:

-   Lowest latency & no polling: In a streaming-first fashion, the Firehose nodes are designed to race to push out the block data first.

-   Prevents downtimes: Designed from the ground up for High Availability.

-   Never miss a beat: The Firehose stream cursor is designed to handle forks and to continue where you left off in any condition.

-   Richest data model:  Best data model that includes the balance changes, the full call tree, internal transactions, logs, storage changes, gas costs, and more.

-   Leverages flat files: Blockchain data is extracted into flat files, the cheapest and most optimized computing resource available.

## Where can developers access more information about Substreams-powered subgraphs and Substreams?

The [Substreams documentation](/substreams/README/) will teach you how to build Substreams modules.

The [Substreams-powered subgraphs documentation](/cookbook/substreams-powered-subgraphs/) will show you how to package them for deployment on The Graph.

## What is the role of Rust modules in Substreams?

Rust modules are the equivalent of the AssemblyScript mappers in subgraphs. They are compiled to WASM in a similar way, but the programming model allows for parallel execution. They define the sort of transformations and aggregations you want to apply to the raw blockchain data.

See [modules documentation](/substreams/developers-guide/modules/types/) for details.

## What makes Substreams composable?

When using Substreams, the composition happens at the transformation layer enabling cached modules to be re-used.

As an example, Alice can build a DEX price module, Bob can use it to build a volume aggregator for some tokens of his interest, and Lisa can combine four individual DEX price modules to create a price oracle. A single Substreams request will package all of these individual's modules, link them together, to offer a much more refined stream of data. That stream can then be used to populate a subgraph, and be queried by consumers.

## How can you build and deploy a Substreams-powered Subgraph?

After [defining](/cookbook/substreams-powered-subgraphs/) a Substreams-powered Subgraph, you can use the Graph CLI to deploy it in [Subgraph Studio](https://thegraph.com/studio/).

## Where can I find examples of Substreams and Substreams-powered subgraphs?

You can visit [this Github repo](https://github.com/pinax-network/awesome-substreams) to find examples of Substreams and Substreams-powered subgraphs.

## What do Substreams and Substreams-powered subgraphs mean for The Graph Network?

The integration promises many benefits, including extremely high-performance indexing and greater composability by leveraging community modules and building on them.
