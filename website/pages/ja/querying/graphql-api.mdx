---
title: GraphQL API
---

Graph Protocol で使用される GraphQL Query API について説明します。

## クエリ

サブグラフのスキーマには、`Entities`と呼ばれるタイプが定義されています。各`Entity`タイプには、トップレベルの`Query`タイプに`entity`と`entities`フィールドが生成されます。なお、The Graph を使用する際には、`graphql`の`query` の先頭にクエリを含める必要はありません。

### 例

スキーマで定義された 1 つの`Token`エンティティに対するクエリ:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> **注:** 単一のエンティティを照会する場合、`id` フィールドは必須であり、文字列でなければなりません。

すべての `Token` エンティティをクエリします。

```graphql
{
  tokens {
    id
    owner
  }
}
```

### 並べ替え

コレクションをクエリする場合、`orderBy` パラメータを使用して特定の属性で並べ替えることができます。さらに、`orderDirection` を使用してソート方向を指定できます。昇順の場合は `asc`、降順の場合は `desc` です。

#### 例

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### ネストされたエンティティの並べ替えの例

グラフ ノード [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) の時点で、エンティティを並べ替えることができますネストされたエンティティに基づいています。

次の例では、所有者の名前でトークンを並べ替えます。

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> Currently, you can sort by one-level deep `String` or `ID` types on `@entity` and `@derivedFrom` fields. Unfortunately, [sorting by interfaces on one level-deep entities](https://github.com/graphprotocol/graph-node/pull/4058), sorting by fields which are arrays and nested entities is not yet supported.

### ページネーション

When querying a collection, the `first` parameter can be used to paginate from the beginning of the collection. It is worth noting that the default sort order is by ID in ascending alphanumeric order, not by creation time.

Further, the `skip` parameter can be used to skip entities and paginate. e.g. `first:100` shows the first 100 entities and `first:100, skip:100` shows the next 100 entities.

Queries should avoid using very large `skip` values since they generally perform poorly. For retrieving a large number of items, it is much better to page through entities based on an attribute as shown in the last example.

#### `first` を使用した例

最初の 10 個のトークンを照会します。

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

To query for groups of entities in the middle of a collection, the `skip` parameter may be used in conjunction with the `first` parameter to skip a specified number of entities starting at the beginning of the collection.

#### `first` と `skip` を使用した例

コレクションの先頭から 10 桁ずれた 10 個の `Token` エンティティをクエリします。

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### `first` と `id_ge` を使用した例

If a client needs to retrieve a large number of entities, it is much more performant to base queries on an attribute and filter by that attribute. For example, a client would retrieve a large number of tokens using this query:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

The first time, it would send the query with `lastID = ""`, and for subsequent requests would set `lastID` to the `id` attribute of the last entity in the previous request. This approach will perform significantly better than using increasing `skip` values.

### フィルタリング

You can use the `where` parameter in your queries to filter for different properties. You can filter on mulltiple values within the `where` parameter.

#### `where` を使用した例

`failed` 結果のクエリ チャレンジ:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

値の比較には、`_gt`、`_lte` などのサフィックスを使用できます。

#### 範囲フィルタリングの例

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### ブロックフィルタリングの例

You can also filter entities by the `_change_block(number_gte: Int)` - this filters entities which were updated in or after the specified block.

This can be useful if you are looking to fetch only entities which have changed, for example since the last time you polled. Or alternatively it can be useful to investigate or debug how entities are changing in your subgraph (if combined with a block filter, you can isolate only entities that changed in a specific block).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### ネストされたエンティティ フィルタリングの例

Filtering on the basis of nested entities is possible in the fields with the `_` suffix.

This can be useful if you are looking to fetch only entities whose child-level entities meet the provided conditions.

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### 論理演算子

As of Graph Node [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) you can group multiple parameters in the same `where` argument using the `and` or the `or` operators to filter results based on more than one criteria.

##### `AND` 演算子

次の例では、`outcome` `succeeded` および `number` が `100` 以上のチャレンジをフィルタリングしています。

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **シンタックス シュガー:** コンマで区切られた部分式を渡すことで `and` 演算子を削除することで、上記のクエリを簡素化できます。
> 
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

##### `OR` 演算子

次の例では、`outcome` `succeeded` または `number` が `100` 以上のチャレンジをフィルタリングしています。

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Note**: When constructing queries, it is important to consider the performance impact of using the `or` operator. While `or` can be a useful tool for broadening search results, it can also have significant costs. One of the main issues with `or` is that it can cause queries to slow down. This is because `or` requires the database to scan through multiple indexes, which can be a time-consuming process. To avoid these issues, it is recommended that developers use and operators instead of or whenever possible. This allows for more precise filtering and can lead to faster, more accurate queries.

#### すべてのフィルター

Full list of parameter suffixes:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Please note that some suffixes are only supported for specific types. For example, `Boolean` only supports `_not`, `_in`, and `_not_in`, but `_` is available only for object and interface types.

さらに、次のグローバル フィルターを `where` 引数の一部として使用できます。

```gr
_change_block(number_gte: Int)
```

### タイムトラベル クエリ

You can query the state of your entities not just for the latest block, which is the default, but also for an arbitrary block in the past. The block at which a query should happen can be specified either by its block number or its block hash by including a `block` argument in the toplevel fields of queries.

The result of such a query will not change over time, i.e., querying at a certain past block will return the same result no matter when it is executed, with the exception that if you query at a block very close to the head of the chain, the result might change if that block turns out to not be on the main chain and the chain gets reorganized. Once a block can be considered final, the result of the query will not change.

Note that the current implementation is still subject to certain limitations that might violate these gurantees. The implementation can not always tell that a given block hash is not on the main chain at all, or that the result of a query by block hash for a block that can not be considered final yet might be influenced by a block reorganization running concurrently with the query. They do not affect the results of queries by block hash when the block is final and known to be on the main chain. [This issue](https://github.com/graphprotocol/graph-node/issues/1405) explains what these limitations are in detail.

#### 例

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing block number 8,000,000.

#### 例

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing the block with the given hash.

### 全文検索クエリ

Fulltext search query fields provide an expressive text search API that can be added to the subgraph schema and customized. Refer to [Defining Fulltext Search Fields](/developing/creating-a-subgraph#defining-fulltext-search-fields) to add fulltext search to your subgraph.

Fulltext search queries have one required field, `text`, for supplying search terms. Several special fulltext operators are available to be used in this `text` search field.

全文検索演算子:

| シンボル        | オペレーター      | 説明書き                                                      |
| ----------- | ----------- | --------------------------------------------------------- |
| `&`     | `と`         | 複数の検索語を組み合わせて、指定したすべての検索語を含むエンティティをフィルタリングします。            |
| &#x7c;      | `Or`        | 複数の検索語をオペレーターで区切って検索すると、指定した語のいずれかにマッチするすべてのエンティティが返されます。 |
| `<->` | `Follow by` | 2 つの単語の間の距離を指定します。                                        |
| `:*`        | `プレフィックス`   | プレフィックス検索語を使って、プレフィックスが一致する単語を検索します（2 文字必要）               |

#### 例

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their fulltext fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies a words a specific distance apart in the fulltext documents. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combine fulltext operators to make more complex filters. With a pretext search operator combined with a follow by this example query will match all blog entities with words that start with "lou" followed by "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### 認証

Graph Node implements [specification-based](https://spec.graphql.org/October2021/#sec-Validation) validation of the GraphQL queries it receives using [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), which is based on the [graphql-js reference implementation](https://github.com/graphql/graphql-js/tree/main/src/validation). Queries which fail a validation rule do so with a standard error - visit the [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) to learn more.

## スキーマ

The schema of your data source--that is, the entity types, values, and relationships that are available to query--are defined through the [GraphQL Interface Definition Langauge (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

GraphQL schemas generally define root types for `queries`, `subscriptions` and `mutations`. The Graph only supports `queries`. The root `Query` type for your subgraph is automatically generated from the GraphQL schema that's included in your subgraph manifest.

> **Note:** Our API does not expose mutations because developers are expected to issue transactions directly against the underlying blockchain from their applications.

### エンティティ

スキーマ内の `@entity` ディレクティブを持つすべての GraphQL タイプはエンティティとして扱われ、 `ID` フィールドが必要です。

> **注:** 現在、スキーマ内のすべてのタイプに `@entity` ディレクティブが必要です。将来的には、`@entity` ディレクティブのない型を値オブジェクトとして扱いますが、これはまだサポートされていません。

### サブグラフ メタデータ

All subgraphs have an auto-generated `_Meta_` object, which provides access to subgraph metadata. This can be queried as follows:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

If a block is provided, the metadata is as of that block, if not the latest indexed block is used. If provided, the block must be after the subgraph's start block, and less than or equal to the most recently indexed block.

`deployment` は、`subgraph.yaml` ファイルの IPFS CID に対応する一意の ID です。

`block` は、最新のブロックに関する情報を提供します (`_meta` に渡されたブロック制約を考慮します):

- hash: ブロックのハッシュ
- number: ブロック番号
- timestamp: 可能であれば、ブロックのタイムスタンプ (これは現在、EVMネットワークのインデックスを作成するサブグラフでのみ利用可能)

`hasIndexingErrors` は、サブグラフが過去のブロックでインデックス作成エラーに遭遇したかどうかを識別するブール値です
