---
title: GraphQL 検証移行ガイド
---

まもなく「graph-node」は [GraphQL Validations 仕様](https://spec.graphql.org/June2018/#sec-Validation) を 100% カバーします。

Previous versions of `graph-node` did not support all validations and provided more graceful responses - so, in cases of ambiguity, `graph-node` was ignoring invalid GraphQL operations components.

GraphQL Validations サポートは、今後の新機能と The Graph Network の大規模なパフォーマンスの柱です。

また、The Graph Network の重要な要件であるクエリ応答の決定性も保証されます。

**GraphQL Validations を有効にすると、The Graph API に送信された既存のクエリの一部が壊れます**。

これらの検証に準拠するには、移行ガイドに従ってください。

> ⚠️ If you do not migrate your queries before the validations are rolled out, they will return errors and possibly break your frontends/clients.

## 移行ガイド

You can use the CLI migration tool to find any issues in your GraphQL operations and fix them. Alternatively you can update the endpoint of your GraphQL client to use the `https://api-next.thegraph.com/subgraphs/name/$GITHUB_USER/$SUBGRAPH_NAME` endpoint. Testing your queries against this endpoint will help you find the issues in your queries.

> Not all subgraphs will need to be migrated, if you are using [GraphQL ESlint](https://the-guild.dev/graphql/eslint/docs) or [GraphQL Code Generator](https://the-guild.dev/graphql/codegen), they already ensure that your queries are valid.

## 移行 CLI ツール

**GraphQL 操作エラーのほとんどは、事前にコードベースで見つけることができます。**

このため、開発中または CI で GraphQL 操作を検証するためのスムーズなエクスペリエンスを提供します。

[`@graphql-validate/cli`](https://github.com/saihaj/graphql-validate) は、特定のスキーマに対して GraphQL 操作を検証するのに役立つシンプルな CLI ツールです。

### **入門**

ツールは次のように実行できます。

```bash
npx @graphql-validate/cli -s https://api-next.thegraph.com/subgraphs/name/$GITHUB_USER/$SUBGRAPH_NAME -o *.graphql
```

**ノート：**

-   $GITHUB_USER、$SUBGRAPH_NAME を適切な値に設定または置き換えます。のように: [`artblocks/art-blocks`](https://api.thegraph.com/subgraphs/name/artblocks/art-blocks)
-   The preview schema URL (https://api-next.thegraph.com/) provided is heavily rate-limited and will be sunset once all users have migrated to the new version. **Do not use it in production.**
-   Operations are identified in files with the following extensions [`.graphql`,](https://www.graphql-tools.com/docs/schema-loading#graphql-file-loader)[`.ts`, `.tsx`, `.js`, `jsx`](https://www.graphql-tools.com/docs/schema-loading#code-file-loader) (`-o` option).

### CLI 出力

`[@graphql-validate/cli](https://github.com/saihaj/graphql-validate)` CLI ツールは、GraphQL 操作エラーを次のように出力します。

![CLIからのエラー出力](https://i.imgur.com/x1cBdhq.png)

エラーごとに、説明、ファイル パスと位置、および解決例へのリンクが表示されます (次のセクションを参照)。

## プレビュー スキーマに対してローカル クエリを実行する

検証がオンになっている「graph-node」バージョンを実行するエンドポイント「https://api-next.thegraph.com/」を提供します。

クエリを次の宛先に送信して試すことができます。

-   `https://api-next.thegraph.com/subgraphs/id/<Qm...>`

または

-   `https://api-next.thegraph.com/subgraphs/name/<GITHUB_USER>/<SUBGRAPH_NAME>`

To work on queries that have been flagged as having validation errors, you can use your favorite GraphQL query tool, like Altair or [GraphiQL](https://cloud.hasura.io/public/graphiql), and try your query out. Those tools will also mark those errors in their UI, even before you run it.

## 問題を解決する方法

以下に、既存の GraphQL 操作で発生する可能性があるすべての GraphQL 検証エラーを示します。

### GraphQL の変数、操作、フラグメント、または引数は一意である必要があります

We applied rules for ensuring that an operation includes a unique set of GraphQL variables, operations, fragments, and arguments.

GraphQL 操作は、あいまいさが含まれていない場合にのみ有効です。

これを実現するには、GraphQL 操作の一部のコンポーネントが一意でなければならないことを確認する必要があります。

これらの規則に違反するいくつかの無効な操作の例を次に示します。

**クエリ名が重複しています (#UniqueOperationNamesRule)**

```graphql
# The following operation violated the UniqueOperationName
# rule, since we have a single operation with 2 queries
# with the same name
query myData {
  id
}

query myData {
  name
}
```

_解決：_

```graphql
query myData {
  id
}

query myData2 {
  # rename the second query
  name
}
```

**フラグメント名の重複 (#UniqueFragmentNamesRule)**

```graphql
# The following operation violated the UniqueFragmentName
# rule.
query myData {
  id
  ...MyFields
}

fragment MyFields {
  metadata
}

fragment MyFields {
  name
}
```

_解決：_

```graphql
query myData {
  id
  ...MyFieldsName
  ...MyFieldsMetadata
}

fragment MyFieldsMetadata { # assign a unique name to fragment
  metadata
}

fragment MyFieldsName { # assign a unique name to fragment
  name
}
```

**Duplicate variable name (#UniqueVariableNamesRule)**

```graphql
# The following operation violates the UniqueVariables
query myData($id: String, $id: Int) {
  id
  ...MyFields
}
```

_解決：_

```graphql
query myData($id: String) {
  # keep the relevant variable (here: `$id: String`)
  id
  ...MyFields
}
```

**Duplicate argument name (#UniqueArgument)**

```graphql
# The following operation violated the UniqueArguments
query myData($id: ID!) {
  userById(id: $id, id: "1") {
    id
  }
}
```

_解決：_

```graphql
query myData($id: ID!) {
  userById(id: $id) {
    id
  }
}
```

**Duplicate anonymous query (#LoneAnonymousOperationRule)**

Also, using two anonymous operations will violate the `LoneAnonymousOperation` rule due to conflict in the response structure:

```graphql
# This will fail if executed together in
# a single operation with the following two queries:
query {
  someField
}

query {
  otherField
}
```

_解決：_

```graphql
query {
  someField
  otherField
}
```

または、2 つのクエリに名前を付けます。

```graphql
query FirstQuery {
  someField
}

query SecondQuery {
  otherField
}
```

### 重複するフィールド

GraphQL 選択セットは、最終的な結果セットを正しく解決する場合にのみ有効と見なされます。

If a specific selection set, or a field, creates ambiguity either by the selected field or by the arguments used, the GraphQL service will fail to validate the operation.

この規則に違反する無効な操作の例をいくつか示します。

**競合するフィールド エイリアス (#OverlappingFieldsCanBeMergedRule)**

```graphql
# Aliasing fields might cause conflicts, either with
# other aliases or other fields that exist on the
# GraphQL schema.
query {
  dogs {
    name: nickname
    name
  }
}
```

_解決：_

```graphql
query {
  dogs {
    name: nickname
    originalName: name # alias the original `name` field
  }
}
```

**引数を持つフィールドの競合 (#OverlappingFieldsCanBeMergedRule)**

```graphql
# Different arguments might lead to different data,
# so we can't assume the fields will be the same.
query {
  dogs {
    doesKnowCommand(dogCommand: SIT)
    doesKnowCommand(dogCommand: HEEL)
  }
}
```

_解決：_

```graphql
query {
  dogs {
    knowsHowToSit: doesKnowCommand(dogCommand: SIT)
    knowsHowToHeel: doesKnowCommand(dogCommand: HEEL)
  }
}
```

また、より複雑なユースケースでは、最終的に予想されるセットで競合を引き起こす可能性のある 2 つのフラグメントを使用して、この規則に違反する可能性があります。

```graphql
query {
  # Eventually, we have two "x" definitions, pointing
  # to different fields!
  ...A
  ...B
}

fragment A on Type {
  x: a
}

fragment B on Type {
  x: b
}
```

それに加えて、`@skip` や `@include` などのクライアント側の GraphQL ディレクティブは、あいまいさにつながる可能性があります。次に例を示します。

```graphql
fragment mergeSameFieldsWithSameDirectives on Dog {
  name @include(if: true)
  name @include(if: false)
}
```

[アルゴリズムの詳細については、こちらをご覧ください](https://spec.graphql.org/June2018/#sec-Field-Selection-Merging)

### 未使用の変数またはフラグメント

GraphQL 操作も、操作で定義されたすべてのコンポーネント (変数、フラグメント) が使用されている場合にのみ有効と見なされます。

これらのルールに違反する GraphQL 操作の例をいくつか示します:

**未使用の変数** (#NoUnusedVariablesRule)

```graphql
# Invalid, because $someVar is never used.
query something($someVar: String) {
  someData
}
```

_解決：_

```graphql
query something {
  someData
}
```

**未使用のフラグメント** (#NoUnusedFragmentsRule)

```graphql
# Invalid, because fragment AllFields is never used.
query something {
  someData
}

fragment AllFields { # unused :(
  name
  age
}
```

_解決：_

```graphql
# Invalid, because fragment AllFields is never used.
query something {
  someData
}

# remove the `AllFields` fragment
```

### 無効または欠落している選択セット (#ScalarLeafsRule)

また、GraphQL フィールドの選択は、以下が検証された場合にのみ有効です:

-   オブジェクト フィールドには選択セットが指定されている必要があります。
-   エッジ フィールド (スカラー、列挙型) には、選択セットが指定されていてはなりません。

次のスキーマでこれらの規則に違反する例をいくつか示します:

```graphql
schema {
  type Image {
   url: String!
  }

  type User {
   id: ID!
   avatar: Image!
  }

  type Query {
    user: User!
  }
}
```

**無効な選択セット**

```graphql
query {
  user {
    id { # Invalid, because "id" is of type ID and does not have sub-fields

    }
  }
}
```

_解決：_

```graphql
query {
  user {
    id
  }
}
```

**選択セットがありません**

```graphql
query {
  user {
    id
    image # `image` requires a Selection-Set for sub-fields!
  }
}
```

_解決：_

```graphql
query {
  user {
    id
    image {
      src
    }
  }
}
```

### 引数の値が正しくない (#VariablesInAllowedPositionRule)

ハードコーディングされた値を引数に渡す GraphQL 操作は、スキーマで定義された値に基づいて有効である必要があります。

これらの規則に違反する無効な操作の例をいくつか示します:

```graphql
query purposes {
  # If "name" is defined as "String" in the schema,
  # this query will fail during validation.
  purpose(name: 1) {
    id
  }
}

# This might also happen when an incorrect variable is defined:

query purposes($name: Int!) {
  # If "name" is defined as `String` in the schema,
  # this query will fail during validation, because the
  # variable used is of type `Int`
  purpose(name: $name) {
    id
  }
}
```

### 不明な型、変数、フラグメント、またはディレクティブ (#UnknownX)

不明なタイプ、変数、フラグメント、またはディレクティブが使用されている場合、GraphQL API はエラーを発生させます。

これらの不明な参照は修正する必要があります:

-   タイプミスだった場合の名前の変更
-   それ以外の場合は、削除します

### フラグメント: 無効なスプレッドまたは定義

**無効なフラグメント スプレッド (#PossibleFragmentSpreadsRule)**

Fragment は、適用できない型に展開できません。

たとえば、`Cat` フラグメントを `Dog` タイプに適用することはできません。

```graphql
query {
	dog {
		...CatSimple
  }
}

fragment CatSimple on Cat {
  # ...
}
```

**無効なフラグメント定義 (#FragmentsOnCompositeTypesRule)**

すべての Fragment は、(`on ...` を使用して) 複合型、つまり、オブジェクト、インターフェイス、またはユニオンで定義する必要があります。

スカラーでのフラグメントの定義は無効であるため、次の例は無効です。

```graphql
ragment fragOnScalar on Int {
  # we cannot define a fragment upon a scalar (`Int`)
  something
}

fragment inlineFragOnScalar on Dog {
  ... on Boolean {
    # `Boolean` is not a subtype of `Dog`
    somethingElse
  }
}
```

### ディレクティブの使用

**ディレクティブはこの場所では使用できません (#KnownDirectivesRule)**

The Graph API でサポートされている GraphQL ディレクティブ (`@...`) のみを使用できます。

以下は、GraphQL がサポートするディレクティブの例です:

```graphql
query {
  dog {
    name @include(true)
    age @skip(true)
  }
}
```

\_注: `@stream`、`@live`、`@defer` はサポートされていません。

**ディレクティブは、この場所で 1 回だけ使用できます (#UniqueDirectivesPerLocationRule)**

The Graph でサポートされているディレクティブは、場所ごとに 1 回だけ使用できます。

以下は無効です (そして冗長です):

```graphql
query {
  dog {
    name @include(true) @include(true)
  }
}
```
