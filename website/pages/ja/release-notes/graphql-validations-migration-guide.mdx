---
title: GraphQL 検証移行ガイド
---

まもなく「graph-node」は [GraphQL Validations 仕様](https://spec.graphql.org/June2018/#sec-Validation) を 100% カバーします。

Previous versions of `graph-node` did not support all validations and provided more graceful responses - so, in cases of ambiguity, `graph-node` was ignoring invalid GraphQL operations components.

GraphQL Validations サポートは、今後の新機能と The Graph Network の大規模なパフォーマンスの柱です。

また、The Graph Network の重要な要件であるクエリ応答の決定性も保証されます。

**GraphQL Validations を有効にすると、The Graph API に送信された既存のクエリの一部が壊れます**。

これらの検証に準拠するには、移行ガイドに従ってください。

> ⚠️ If you do not migrate your queries before the validations are rolled out, they will return errors and possibly break your frontends/clients.

## 移行ガイド

You can use the CLI migration tool to find any issues in your GraphQL operations and fix them. Alternatively you can update the endpoint of your GraphQL client to use the `https://api-next.thegraph.com/subgraphs/name/$GITHUB_USER/$SUBGRAPH_NAME` endpoint. Testing your queries against this endpoint will help you find the issues in your queries.

> Not all subgraphs will need to be migrated, if you are using [GraphQL ESlint](https://the-guild.dev/graphql/eslint/docs) or [GraphQL Code Generator](https://the-guild.dev/graphql/codegen), they already ensure that your queries are valid.

## 移行 CLI ツール

**GraphQL 操作エラーのほとんどは、事前にコードベースで見つけることができます。**

For this reason, we provide a smooth experience for validating your GraphQL operations during development or in CI.

[`@graphql-validate/cli`](https://github.com/saihaj/graphql-validate) は、特定のスキーマに対して GraphQL 操作を検証するのに役立つシンプルな CLI ツールです。

### **入門**

ツールは次のように実行できます。

```bash
npx @graphql-validate/cli -s https://api-next.thegraph.com/subgraphs/name/$GITHUB_USER/$SUBGRAPH_NAME -o *.graphql
```

**ノート：**

-   $GITHUB_USER、$SUBGRAPH_NAME を適切な値に設定または置き換えます。のように: [`artblocks/art-blocks`](https://api.thegraph.com/subgraphs/name/artblocks/art-blocks)
-   The preview schema URL (https://api-next.thegraph.com/) provided is heavily rate-limited and will be sunset once all users have migrated to the new version. **Do not use it in production.**
-   Operations are identified in files with the following extensions [`.graphql`,](https://www.graphql-tools.com/docs/schema-loading#graphql-file-loader)[`.ts`, `.tsx`, `.js`, `jsx`](https://www.graphql-tools.com/docs/schema-loading#code-file-loader) (`-o` option).

### CLI 出力

`[@graphql-validate/cli](https://github.com/saihaj/graphql-validate)` CLI ツールは、GraphQL 操作エラーを次のように出力します。

![CLIからのエラー出力](https://i.imgur.com/x1cBdhq.png)

エラーごとに、説明、ファイル パスと位置、および解決例へのリンクが表示されます (次のセクションを参照)。

## プレビュー スキーマに対してローカル クエリを実行する

We provide an endpoint `https://api-next.thegraph.com/` that runs a `graph-node` version that has validations turned on.

クエリを次の宛先に送信して試すことができます。

-   `https://api-next.thegraph.com/subgraphs/id/<Qm...>`

または

-   `https://api-next.thegraph.com/subgraphs/name/<GITHUB_USER>/<SUBGRAPH_NAME>`

To work on queries that have been flagged as having validation errors, you can use your favorite GraphQL query tool, like Altair or [GraphiQL](https://cloud.hasura.io/public/graphiql), and try your query out. Those tools will also mark those errors in their UI, even before you run it.

## 問題を解決する方法

Below, you will find all the GraphQL validations errors that could occur on your existing GraphQL operations.

### GraphQL の変数、操作、フラグメント、または引数は一意である必要があります

We applied rules for ensuring that an operation includes a unique set of GraphQL variables, operations, fragments, and arguments.

GraphQL 操作は、あいまいさが含まれていない場合にのみ有効です。

To achieve that, we need to ensure that some components in your GraphQL operation must be unique.

これらの規則に違反するいくつかの無効な操作の例を次に示します。

**クエリ名が重複しています (#UniqueOperationNamesRule)**

```graphql
# 次の操作は UniqueOperationName に違反しました
# ルール、2 つのクエリで 1 つの操作があるため
#同名
myData のクエリ{
  id
}

query myData {
  name
}
```

_解決：_

```graphql
query myData {
  id
}

query myData2 {
  # rename the second query
  name
}
```

**フラグメント名の重複 (#UniqueFragmentNamesRule)**

```graphql
# The following operation violated the UniqueFragmentName
# rule.
query myData {
  id
  ...MyFields
}

fragment MyFields {
  metadata
}

fragment MyFields {
  name
}
```

_解決：_

```graphql
query myData {
  id
  ...MyFieldsName
  ...MyFieldsMetadata
}

fragment MyFieldsMetadata { # assign a unique name to fragment
  metadata
}

fragment MyFieldsName { # assign a unique name to fragment
  name
}
```

**Duplicate variable name (#UniqueVariableNamesRule)**

```graphql
# The following operation violates the UniqueVariables
query myData($id: String, $id: Int) {
  id
  ...MyFields
}
```

_解決：_

```graphql
query myData($id: String) {
  # keep the relevant variable (here: `$id: String`)
  id
  ...MyFields
}
```

**Duplicate argument name (#UniqueArgument)**

```graphql
# The following operation violated the UniqueArguments
query myData($id: ID!) {
  userById(id: $id, id: "1") {
    id
  }
}
```

_解決：_

```graphql
query myData($id: ID!) {
  userById(id: $id) {
    id
  }
}
```

**Duplicate anonymous query (#LoneAnonymousOperationRule)**

Also, using two anonymous operations will violate the `LoneAnonymousOperation` rule due to conflict in the response structure:

```graphql
# This will fail if executed together in
# a single operation with the following two queries:
query {
  someField
}

query {
  otherField
}
```

_解決：_

```graphql
query {
  someField
  otherField
}
```

または、2 つのクエリに名前を付けます。

```graphql
query FirstQuery {
  someField
}

query SecondQuery {
  otherField
}
```

### 重複するフィールド

GraphQL 選択セットは、最終的な結果セットを正しく解決する場合にのみ有効と見なされます。

If a specific selection set, or a field, creates ambiguity either by the selected field or by the arguments used, the GraphQL service will fail to validate the operation.

この規則に違反する無効な操作の例をいくつか示します。

**Conflicting fields aliases (#OverlappingFieldsCanBeMergedRule)**

```graphql
# Aliasing fields might cause conflicts, either with
# other aliases or other fields that exist on the
# GraphQL schema.
query {
  dogs {
    name: nickname
    name
  }
}
```

_解決：_

```graphql
query {
  dogs {
    name: nickname
    originalName: name # alias the original `name` field
  }
}
```

**引数を持つフィールドの競合 (#OverlappingFieldsCanBeMergedRule)**

```graphql
# Different arguments might lead to different data,
# so we can't assume the fields will be the same.
query {
  dogs {
    doesKnowCommand(dogCommand: SIT)
    doesKnowCommand(dogCommand: HEEL)
  }
}
```

_解決：_

```graphql
query {
  dogs {
    knowsHowToSit: doesKnowCommand(dogCommand: SIT)
    knowsHowToHeel: doesKnowCommand(dogCommand: HEEL)
  }
}
```

Also, in more complex use-cases, you might violate this rule by using two fragments that might cause a conflict in the eventually expected set:

```graphql
query {
  # Eventually, we have two "x" definitions, pointing
  # to different fields!
  ...A
  ...B
}

fragment A on Type {
  x: a
}

fragment B on Type {
  x: b
}
```

In addition to that, client-side GraphQL directives like `@skip` and `@include` might lead to ambiguity, for example:

```graphql
fragment mergeSameFieldsWithSameDirectives on Dog {
  name @include(if: true)
  name @include(if: false)
}
```

[アルゴリズムの詳細については、こちらをご覧ください](https://spec.graphql.org/June2018/#sec-Field-Selection-Merging)

### 未使用の変数またはフラグメント

A GraphQL operation is also considered valid only if all operation-defined components (variables, fragments) are used.

これらのルールに違反する GraphQL 操作の例をいくつか示します:

**未使用の変数** (#NoUnusedVariablesRule)

```graphql
# Invalid, because $someVar is never used.
query something($someVar: String) {
  someData
}
```

_解決：_

```graphql
query something {
  someData
}
```

**未使用のフラグメント** (#NoUnusedFragmentsRule)

```graphql
# Invalid, because fragment AllFields is never used.
query something {
  someData
}

fragment AllFields { # unused :(
  name
  age
}
```

_解決：_

```graphql
# Invalid, because fragment AllFields is never used.
query something {
  someData
}

# remove the `AllFields` fragment
```

### 無効または欠落している選択セット (#ScalarLeafsRule)

また、GraphQL フィールドの選択は、以下が検証された場合にのみ有効です:

-   オブジェクト フィールドには選択セットが指定されている必要があります。
-   エッジ フィールド (スカラー、列挙型) には、選択セットが指定されていてはなりません。

次のスキーマでこれらの規則に違反する例をいくつか示します:

```graphql
schema {
  type Image {
   url: String!
  }

  type User {
   id: ID!
   avatar: Image!
  }

  type Query {
    user: User!
  }
}
```

**無効な選択セット**

```graphql
query {
  user {
    id { # Invalid, because "id" is of type ID and does not have sub-fields

    }
  }
}
```

_解決：_

```graphql
query {
  user {
    id
  }
}
```

**選択セットがありません**

```graphql
query {
  user {
    id
    image # `image` requires a Selection-Set for sub-fields!
  }
}
```

_解決：_

```graphql
query {
  user {
    id
    image {
      src
    }
  }
}
```

### 引数の値が正しくない (#VariablesInAllowedPositionRule)

GraphQL operations that pass hard-coded values to arguments must be valid, based on the value defined in the schema.

これらの規則に違反する無効な操作の例をいくつか示します:

```graphql
query purposes {
  # If "name" is defined as "String" in the schema,
  # this query will fail during validation.
  purpose(name: 1) {
    id
  }
}

# This might also happen when an incorrect variable is defined:

query purposes($name: Int!) {
  # If "name" is defined as `String` in the schema,
  # this query will fail during validation, because the
  # variable used is of type `Int`
  purpose(name: $name) {
    id
  }
}
```

### 不明な型、変数、フラグメント、またはディレクティブ (#UnknownX)

不明なタイプ、変数、フラグメント、またはディレクティブが使用されている場合、GraphQL API はエラーを発生させます。

これらの不明な参照は修正する必要があります:

-   タイプミスだった場合の名前の変更
-   それ以外の場合は、削除します

### フラグメント: 無効なスプレッドまたは定義

**無効なフラグメント スプレッド (#PossibleFragmentSpreadsRule)**

Fragment は、適用できない型に展開できません。

たとえば、`Cat` フラグメントを `Dog` タイプに適用することはできません。

```graphql
query {
	dog {
		...CatSimple
  }
}

fragment CatSimple on Cat {
  # ...
}
```

**無効なフラグメント定義 (#FragmentsOnCompositeTypesRule)**

All Fragment must be defined upon (using `on ...`) a composite type, in short: object, interface, or union.

スカラーでのフラグメントの定義は無効であるため、次の例は無効です。

```graphql
ragment fragOnScalar on Int {
  # we cannot define a fragment upon a scalar (`Int`)
  something
}

fragment inlineFragOnScalar on Dog {
  ... on Boolean {
    # `Boolean` is not a subtype of `Dog`
    somethingElse
  }
}
```

### ディレクティブの使用

**ディレクティブはこの場所では使用できません (#KnownDirectivesRule)**

The Graph API でサポートされている GraphQL ディレクティブ (`@...`) のみを使用できます。

以下は、GraphQL がサポートするディレクティブの例です:

```graphql
query {
  dog {
    name @include(true)
    age @skip(true)
  }
}
```

\_注: `@stream`、`@live`、`@defer` はサポートされていません。

**ディレクティブは、この場所で 1 回だけ使用できます (#UniqueDirectivesPerLocationRule)**

The Graph でサポートされているディレクティブは、場所ごとに 1 回だけ使用できます。

以下は無効です (そして冗長です):

```graphql
query {
  dog {
    name @include(true) @include(true)
  }
}
```
