---
title: 新しいネットワークの統合
---

Graph Nodeは現在、以下のチェーンタイプからデータをインデックス化できます：

-   Ethereum, via EVM JSON-RPC and [Ethereum Firehose](https://github.com/streamingfast/firehose-ethereum)
-   NEAR, via a [NEAR Firehose](https://github.com/streamingfast/near-firehose-indexer)
-   Cosmos, via a [Cosmos Firehose](https://github.com/graphprotocol/firehose-cosmos)
-   Arweave, via an [Arweave Firehose](https://github.com/graphprotocol/firehose-arweave)

もしご興味があるチェーンがあれば、統合はGraph Nodeの設定とテストの問題です。

もしも異なるチェーンタイプに興味がある場合は、新しいGraph Nodeを構築する必要があります。私たちの推奨するアプローチは、まず対象のチェーン用の新しいFirehoseを開発し、それをGraph Nodeと統合することです。詳細は以下に記載しています。

**1. EVM JSON-RPC**

ブロックチェーンが EVM と同等であり、クライアント/ノードが標準の EVM JSON-RPC API を公開している場合、グラフ ノードは新しいチェーンのインデックスを作成できるはずです。 詳細については、「EVM JSON-RPC のテスト」(new-chain-integration#testing-an-evm-json-rpc) を参照してください。

**2. Firehose**

EVMをベースとしないチェーンに対しては、Graph NodeはgRPCおよび既知のタイプ定義を介してブロックチェーンデータを取り込む必要があります。これは、ファイルベースとストリーミングファーストのアプローチを使用した、高度にスケーラブルなブロックチェーンインデックス化ソリューションを提供する、[StreamingFast](https://www.streamingfast.io/)によって開発された新しい技術である [Firehose](firehose/README/)を介して行うことができます。Firehoseの開発に関する支援が必要な場合は、[StreamingFast team](mailto:integrations@streamingfast.io)チームにお問い合わせください。

## EVM JSON-RPC と Firehose の違い

これらの2つの方法は、サブグラフに適していますが、[Substreams](substreams/), を使用して開発者がビルドする場合、常にFirehoseが必要です。これには、[Substreams-powered subgraphs](cookbook/substreams-powered-subgraphs/) のようなサブストリームを活用したサブグラフの構築が含まれます。さらに、FirehoseはJSON-RPCと比較して、改善されたインデックス化速度を提供します。

新しいEVMチェーンの統合者は、サブストリームの利点とその大規模な並列化されたインデックス化能力を考慮して、Firehoseベースのアプローチも検討することができます。両方をサポートすることで、開発者は新しいチェーンに対してサブストリームまたはサブグラフのどちらを構築するかを選択できるようになります。

> **NOTE**: A Firehose-based integration for EVM chains will still require Indexers to run the chain's archive RPC node to properly index subgraphs. This is due to the Firehose's inability to provide smart contract state typically accessible by the `eth_call` RPC method. (It's worth reminding that eth_calls are [not a good practice for developers](https://thegraph.com/blog/improve-subgraph-performance-reduce-eth-calls/))

* * *

## Testing an EVM JSON-RPC

For Graph Node to be able to ingest data from an EVM chain, the RPC node must expose the following EVM JSON RPC methods:

-   `eth_getLogs`
-   `eth_call` \_(for historical blocks, with EIP-1898 - requires archive node):
-   `eth_getBlockByNumber`
-   `eth_getBlockByHash`
-   `net_version`
-   `eth_getTransactionReceipt`, in a JSON-RPC batch request
-   _`trace_filter`_ _(optionally required for Graph Node to support call handlers)_

### Graph Node Configuration

**Start by preparing your local environment**

1.  [Clone Graph Node](https://github.com/graphprotocol/graph-node)
2.  Modify [this line](https://github.com/graphprotocol/graph-node/blob/master/docker/docker-compose.yml#L22) to include the new network name and the EVM JSON RPC compliant URL
    > Do not change the env var name itself. It must remain `ethereum` even if the network name is different.
3.  Run an IPFS node or use the one used by The Graph: https://api.thegraph.com/ipfs/

\*Test the integration by locally deploying a subgraph\*\*

1.  Install [graph-cli](https://github.com/graphprotocol/graph-cli)
2.  Create a simple example subgraph. Some options are below:
    1.  The pre-packed [Gravitar](https://github.com/graphprotocol/example-subgraph/tree/f89bdd4628efa4badae7367d4919b3f648083323) smart contract and subgraph is a good starting point
    2.  Bootstrap a local subgraph from any existing smart contract or solidity dev environment [using Hardhat with a Graph plugin](https://github.com/graphprotocol/hardhat-graph)
3.  Adapt the resulting `subgraph.yaml` by changing [`dataSources.network`](http://dataSources.network) to the same name previously passed on to Graph Node.
4.  Create your subgraph in Graph Node: `graph create $SUBGRAPH_NAME --node $GRAPH_NODE_ENDPOINT`
5.  Publish your subgraph to Graph Node: `graph deploy $SUBGRAPH_NAME --ipfs $IPFS_ENDPOINT --node $GRAPH_NODE_ENDPOINT`

Graph Node should be syncing the deployed subgraph if there are no errors. Give it time to sync, then send some GraphQL queries to the API endpoint printed in the logs.

* * *

## Integrating a new Firehose-enabled chain

Integrating a new chain is also possible using the Firehose approach. This is currently the best option for non-EVM chains and a requirement for substreams support. Additional documentation focuses on how Firehose works, adding Firehose support for a new chain and integrating it with Graph Node. Recommended docs for integrators:

1.  [General docs on Firehose](firehose/)
2.  [Adding Firehose support for a new chain](firehose/integrate-new-chains/new-blockchains/)
3.  [Integrating Graph Node with a new chain via Firehose](https://github.com/graphprotocol/graph-node/blob/master/docs/implementation/add-chain.md)
