---
title: Bir Sözleşmeyi Değiştirin ve Graftlama ile Geçmişini Koruyun
---

Bu rehberde, mevcut subgraphları graftlayarak yeni subgraphları nasıl oluşturacağınızı ve dağıtacağınızı öğreneceksiniz.

## Graftlama Nedir?

Graftlama, mevcut bir subgraph'daki verileri yeniden kullanır ve daha sonraki bir blokta indekslemeye başlar. Bu, geliştirme sırasında eşleştirmelerdeki basit hataları hızlı bir şekilde geçmek veya mevcut bir subgraph'ın başarısız olduktan sonra geçici olarak tekrar çalışmasını sağlamak için kullanışlıdır. Ayrıca, sıfırdan indekslenmesi uzun süren bir subgraph'a bir özellik eklerken de kullanılabilir.

Graftlanan subgraph, temel subgraphla tamamen aynı olmayan, ancak onunla uyumlu olan bir GraphQL şeması kullanabilir. Kendi başına geçerli bir subgraph şeması olmalıdır, ancak şu şekillerde temel subgraph şemasından sapabilir:

- Varlık türlerini ekler veya kaldırır
- Varlık türlerinden öznitelikleri kaldırır
- Varlık türlerine null yapılabilir öznitelikler ekler
- Null yapılamayan öznitelikleri null yapılabilir özniteliklere dönüştürür
- Numaralandırmalara değerler ekler
- Arayüzleri ekler veya kaldırır
- Arayüzün hangi varlık türleri için uygulandığını değiştirir

Daha fazla bilgi için kontrol edebilirsiniz:

- [Graftlama](https://thegraph.com/docs/en/developing/creating-a-subgraph#grafting-onto-existing-subgraphs)

Bu eğitici içerikte, temel bir kullanım örneğini ele alacağız. Mevcut bir sözleşmeyi özdeş bir sözleşme ile değiştireceğiz (yeni bir adresle, ancak aynı kodla). Ardından, mevcut subgraph'ı yeni sözleşmeyi izleyen "base" subgraph'a graftlayacağız.

## Mevcut Bir Subgraph'ı Oluşturma

Subgraphlar oluşturmak Graph'ın önemli bir parçasıdır ve [burada](http://localhost:3000/en/cookbook/quick-start/) daha ayrıntılı olarak açıklanmıştır. Bu eğitici içerikte kullanılan mevcut subgraph'ı oluşturabilmek ve dağıtabilmek için aşağıdaki Github deposu sağlanmıştır:

- [Subgraph örnek deposu](https://github.com/t-proctor/grafting-tutorial)

> Not: Subgraph'ta kullanılan sözleşme aşağıdaki [Hackathon Starterkit](https://github.com/schmidsi/hackathon-starterkit)'den alınmıştır.

## Subgraph Manifest Tanımı

Subgraph manifesti `subgraph.yaml`, subgraph için veri kaynaklarını, ilgili tetikleyicileri ve bu tetikleyicilere yanıt olarak çalıştırılması gereken fonksiyonları tanımlar. Kullanacağınız örnek bir subgraph bildirimi için aşağıya bakın:

```yaml
specVersion: 0.0.4
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: Lock
    network: goerli
    source:
      address: '0x4Ed995e775D3629b0566D2279f058729Ae6EA493'
      abi: Lock
      startBlock: 7674603
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Withdrawal
      abis:
        - name: Lock
          file: ./abis/Lock.json
      eventHandlers:
        - event: Withdrawal(uint256,uint256)
          handler: handleWithdrawal
      file: ./src/lock.ts
```

- `Lock` veri kaynağı, sözleşmeyi derleyip dağıttığımızda alacağımız abi ve sözleşme adresidir
- Ağ, sorgulanan indekslenmiş bir ağa karşılık gelmelidir. Göerli testnet üzerinde çalıştığımız için, ağ `goerli`
- `mapping` bölümü, ilgili tetikleyicileri ve bu tetikleyicilere yanıt olarak çalıştırılması gereken fonksiyonları tanımlar. Bu durumda, `Withdrawal` olayının etkinliklerini gözlemliyoruz ve yayıldığında `handleWithdrawal` fonksiyonunu çağırıyoruz.

## Graftlama Manifest Tanımı

Graftlama, orijinal subgraph bildirimine iki yeni öğe eklemeyi gerektirir:

```yaml
---
features:
  - grafting # feature name
graft:
  base: Qm... # subgraph ID of base subgraph
  block: 1502122 # block number
```

- `features:` kullanılan tüm [özellik adlarının](developing/creating-a-subgraph/#experimental-features) bir listesidir.
- `graft:` `base` subgraph'ın ve üzerine graftlanacak bloğun bir eşleştirmesidir. `block`, indekslemeye başlanacak blok numarasıdır. Graph, temel subgraph'ın verilerini verilen bloğa kadar ve bu blok dahil olmak üzere kopyalayacak ve ardından yeni subgraph'ı bu bloktan itibaren indekslemeye devam edecektir.

`base` ve `block` değerler iki subgraph kullanılarak bulunabilir: biri temel indeksleme için ve diğeri graftlamalı

## Temel Subgraph'ı Dağıtma

1. [Graph Stüdyo kullanıcı arayüzüne](https://thegraph.com/studio/) gidin ve Göerli testnet üzerinde `graft-example` adında bir subgraph oluşturun
2. Depoda bulunan `graft-example` klasöründeki subgraph sayfanızda bulunan `AUTH & DEPLOY` bölümündeki talimatları izleyin
3. Tamamlandığında, subgraph'ın doğru bir şekilde indekslendiğinden emin olun. Eğer aşağıdaki komutu Graph Test Alanında(Playground) çalıştırırsanız

```graphql
{
  withdrawals(first: 5) {
    id
    amount
    when
  }
}
```

Şuna benzer bir şey döndürür:

```
{
  "data": {
    "withdrawals": [
      {
        "id": "0x13098b538a61837e9f29b32fb40527bbbe63c9120c250242b02b69bb42c287e5-5",
        "amount": "0",
        "when": "1664367528"
      },
      {
        "id": "0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498-3",
        "amount": "0",
        "when": "1664367648"
      }
    ]
  }
}
```

Subgraph'ın düzgün bir şekilde indekslendiğini doğruladıktan sonra, subgraph'ı graftlama ile hızlı bir şekilde güncelleyebilirsiniz.

## Graftlama Subgraph'ını Dağıtma

The graft replacement subgraph.yaml will have a new contract address. This could happen when you update your dapp, redeploy a contract, etc.

1. Go to [The Graph Studio UI](https://thegraph.com/studio/) and create a subgraph on Goerli testnet called `graft-replacement`
2. Create a new manifest. The `subgraph.yaml` for `graph-replacement` contains a different contract address and new information about how it should graft. These are the `block` of the [last event emitted](https://goerli.etherscan.io/tx/0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498) you care about by the old contract and the `base` of the old subgraph. The `base` subgraph ID is the `Deployment ID` of your original `graph-example` subgraph. You can find this in The Graph Studio UI.
3. Follow the directions in the `AUTH & DEPLOY` section on your subgraph page in the `graft-replacement` folder from the repo
4. Tamamlandığında, subgraph'ın doğru bir şekilde indekslendiğinden emin olun. Eğer aşağıdaki komutu Graph Test Alanında(Playground) çalıştırırsanız

```graphql
{
  withdrawals(first: 5) {
    id
    amount
    when
  }
}
```

It should return the following:

```
{
  "data": {
    "withdrawals": [
      {
        "id": "0x13098b538a61837e9f29b32fb40527bbbe63c9120c250242b02b69bb42c287e5-5",
        "amount": "0",
        "when": "1664367528"
      },
      {
        "id": "0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498-3",
        "amount": "0",
        "when": "1664367648"
      },
      {
        "id": "0xb4010e4c76f86762beb997a13cf020231778eaf7c64fa3b7794971a5e6b343d3-22",
        "amount": "0",
        "when": "1664371512"
      }
    ]
  }
}
```

You can see that the `graft-replacement` subgraph is indexing from older `graph-example` data and newer data from the new contract address. The original contract emitted two `Withdrawal` events, [Event 1](https://goerli.etherscan.io/tx/0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498) and [Event 2](https://goerli.etherscan.io/address/0x4ed995e775d3629b0566d2279f058729ae6ea493). The new contract emitted one `Withdrawal` after, [Event 3](https://goerli.etherscan.io/tx/0xb4010e4c76f86762beb997a13cf020231778eaf7c64fa3b7794971a5e6b343d3). The two previously indexed transactions (Event 1 and 2) and the new transaction (Event 3) were combined together in the `graft-replacement` subgraph.

Congrats! You have succesfully grafted a subgraph onto another subgraph.

## Additional Resources

If you want more experience with grafting, here's a few examples for popular contracts:

- [Curve](https://github.com/messari/subgraphs/blob/master/subgraphs/curve-finance/protocols/curve-finance/templates/curve.template.yaml)
- [ERC-721](https://github.com/messari/subgraphs/blob/master/subgraphs/erc721-metadata/subgraph.yaml)
- [Uniswap](https://github.com/messari/subgraphs/blob/master/subgraphs/uniswap-v3/protocols/uniswap-v3/config/templates/uniswap.v3.template.yaml),

To become even more of a Graph expert, consider learning about other ways to handle changes in underlying datasources. Alternatives like [Data Source Templates](developing/creating-a-subgraph/#data-source-templates) can achieve similar results

> Note: A lot of material from this article was taken from the previously published [Arweave article](/cookbook/arweave/)
